                       

#【考察内容】
技术面试主要会涉及到计算机基础、编程、算法、数据结构、项目，建议你从以下方面进行准备：
· 提前复习软件工程的相关基础知识，如操作系统、网络等，面试官会根据你的经历选择交流的侧重点
· 提前练习编码和算法，并且计时，将写出清晰、简洁、bugfree的代码作为你的目标
· 了解常见的计算机数据结构，并理解其在具体场景中的运用方式，对比不同方法间的优劣，找到最优解法
· 整理复盘自己曾经做过的项目，回忆项目的整体架构、技术细节和实现原理
· 以下是一些可能对你有帮助的链接：
## [Leetcode中文版：https://leetcode-cn.com/problemset/all/](https://leetcode-cn.com/problemset/all/)
## [剑指 offer牛客版：https://www.nowcoder.com/ta/coding-interviews](https://www.nowcoder.com/ta/coding-interviews)
价值观和软性技能也是我们选择人才的重要因素


#hybrid性能优化
性能收集
pagespeed
哪些指标快、哪些指标慢



# 图片懒加载，简单写一个判断图片是否在屏幕中展示的函数
function willLazyLoad(image:HTMLElement):boolean{

}

src=空
image元素：容器->内部结构
图片是否出现在屏幕中
两个矩形是否相交


# vue写一个组件，需要能替代原生的a标签
`<a  />`
==>
`<A />`

a标签的属性
href
target
a标签的样式
鼠标悬停
点击

> [《Vue.js快跑：构建触手可及的高性能Web应用》](https://weread.qq.com/web/reader/82032410718487828207501kc81322c012c81e728d9d180)  
> [安装·Vue.js官网](https://cn.vuejs.org/v2/guide/installation.html) 

## Vue Devtools
[https://github.com/vuejs/vue-devtools#vue-devtools](https://github.com/vuejs/vue-devtools#vue-devtools])

## 安装Vue
如何安装并将Vue.js引入网页
* 对于简单的页面，安装Vue不需要任何特殊的工具  
    ```html
    // 有一个ID为app的div元素用于初始化Vue——因为多种原因，不能在body元素上进行初始化。
    <div id="app"></div>
    
    // 在页面上引用CDN[插图]版本的Vue文件。当然也可以下载到本地并引用。
    <script>
    new Vue({
        // 运行一些JavaScript代码，创建一个Vue的实例，并将该实例的el属性指向之前提到的div元素。
        el: '#app',
        created() {
            // 这段代码会在应用启动时运行
        }
    });
    </script>
    ```
   * 直接[下载](https://cn.vuejs.org/v2/guide/installation.html)并用 `<script>` 标签引入，Vue 会被注册为一个全局变量。  
     在开发环境下不要使用压缩版本，不然你就失去了所有常见错误相关的警告!
   * CDN
      * 对于制作原型或学习，你可以这样使用最新版本：  
      https://cdn.jsdelivr.net/npm/vue/dist/vue.js
      * 对于生产环境，我们推荐链接到一个明确的版本号和构建文件，以避免新版本造成的不可预期的破坏：  
      https://cdn.jsdelivr.net/npm/vue@2.6.11
      * 一个兼容 ES Module 的构建文件:  
      https://cdn.jsdelivr.net/npm/vue@2.6.11/dist/vue.esm.browser.js  
      * 在 unpkg 和 cdnjs 上获取 (cdnjs 的版本更新可能略滞后)
         
* 对于任何更加复杂的场景，你可能希望使用类似webpack这样的打包工具。
   * 借助它可以：（在第2章中会有详细介绍）

	   * 使用ECMAScript 2015（甚至更高）标准的JavaScript语言
	   * 编写单文件组件
	   * 实现组件的相互引用
	   * 书写作用域为特定组件的CSS等其他特性
vue-loader是一个webpack的加载器，允许你将一个组件的所有HTML、JavaScript和CSS代码编写到同一个文件中。
   * 如何安装vue-loader
      * 如果已经配置好webpack或者有喜爱的webpack配置模板
可以通过npm安装vue-loader，然后将下面的代码添加到webpack配置的loader部分，就可以完成vue-loader的安装
    ```javascript
    module.exports = {				
        // ...			
        module: {			
            rules: [{		
                test: /\.vue$/,	
                use: 'vue-loader'
            }],		
        },			
    };				
    ```

     * 如果还没有配置好webpack或者正在头疼如何添加vue-loader  
可以使用一份现成的模板来初始化vue项目，它使用了webpack并已经安装好了vue-loader。   
你可以通过vue-cli使用它：
    ```
    $ npm install --global vue-cli
    $ vue init webpack
    ```																							

## html charset
> [《HTML 5与CSS 3权威指南（第4版·上册）》](https://weread.qq.com/web/reader/08532c307171b752085018bk45c322601945c48cce2e120)

HTML 5与HTML 4的区别 · 语法的改变
### HTML 5的语法变化					
* 它的变化，正是因为在HTML 5之前几乎没有符合标准规范的Web浏览器导致的。					
	在这种情况下，各浏览器之间的互兼容性和互操作性在很大程度上取决于网站或网络应用程序的开发者在开发上所做的共同努力				
	而浏览器本身始终是存在缺陷的。				
	在HTML 5中提高Web浏览器之间的兼容性是它的一个很大的目标，为了确保兼容性，就要有一个统一的标准。				
	因此，在HTML 5中，围绕着这个Web标准，重新定义了一套在现有HTML的基础上修改而来的语法，以便各浏览器在运行HTML的时候能够符合一个通用标准。				
* 因为关于HTML 5语法解析的算法也都提供了详细的记载，所以各Web浏览器的供应商可以把**HTML 5分析器**集中封装在自己的浏览器中。					
	最新的Firefox（默认为4.0以后的版本）与WebKit浏览器引擎中都迅速地封装了**供HTML 5使用的分析器**				
	IE（Internet Explorer）与Opera也在努力加快对HTML 5的支持				
	提高浏览器的兼容性指日可待。				
* HTML的语法是在SGML（Standard Generalized MarkupLanguage）语言的基础上建立起来的。					
	但是SGML语法非常复杂，要开发能够解析SGML语法的程序也很不容易，因此很多浏览器都不包含SGML的分析器。				
	因此，虽然HTML基本上遵从SGML的语法，但是对于HTML的执行在各浏览器之间并没有一个统一的标准。				

### 基本语法区别包括
* HTML 5中的标记方法
    1. 内容类型（ContentType）  
    HTML 5的文件扩展符与内容类型保持不变。
       * 扩展符仍然为“.html”或“.htm”
       * 内容类型（ContentType）仍然为“text/html”
    2. DOCTYPE声明  
    DOCTYPE声明是HTML文件中必不可少的，它位于文件第一行。  
       * 在HTML 4中，它的声明方法如下：    
        `<!DOCTYPE html PUBLIC "-// W3c// DTD XHTML 1.0 Transitional// EN" "http://www.w3c.org/TR/xhtml/DTD/xhtml1-transitional.dtd">`
       * 在HTML 5中，刻意不使用版本声明，一份文档将会适用所有版本的HTML。
          * HTML 5中的DOCTYPE声明方法（不区分大小写）如下：  
            `<!DOCTYPE html>`
          * 当使用工具时，也可以在DOCTYPE声明方式中加入SYSTEM识别符，声明方法如下：
            `<!DOCTYPE HTML SYSTEM "about:legacy-compat">`
          在HTML 5中像这样的DOCTYPE声明方式是允许的（不区分大小写，引号不区分是单引号还是双引号）。
    
    3. 指定字符编码
        * 在HTML 4中，使用meta元素的形式指定文件中的字符编码，如下所示：  
        `<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">`
        * 在HTML 5中，可以使用对<meta>元素直接追加charset属性的方式来指定字符编码，如下所示：  
        `<meta charset="UTF-8">`  
        两种方法都有效，可以继续使用前面一种方式（通过content元素的属性来指定），但是不能同时混合使用两种方式。  
        * 在以前的网站代码中可能会存在下面代码所示的标记方式，但在HTML 5中，这种字符编码方式将被认为是错误的，这一点请注意。  
        `<meta charset="UTF8" http-equiv="Content-Type" content="text/html;charset=UTF-8">`  
        从HTML 5开始，对于文件的字符编码推荐使用UTF-8。

* HTML 5确保的兼容性  
这几方面来详细看一下在HTML 5中是如何确保与之前版本的HTML实现兼容的。  
1.可以省略标记的元素  
    在HTML 5中，元素的标记可以省略。  
    具体来说，分为三种类型： 
   * 不允许写结束标记  
   只允许使用“<元素/>”的形式进行书写。
      * area
      * base
      * br  
        HTML 5之前的`<br>`这种写法可以被沿用。
      * col
      * command
      * embed
      * hr
      * img
      * input
      * keygen
      * link
      * meta
      * param
      * source
      * track
      * wbr   
   * 可以省略结束标记
      * li
      * dt
      * dd
      * p
      * rt
      * rp
      * optgroup
      * option
      * colgroup
      * thead
      * tbody
      * tfoot
      * tr
      * td
      * th   
   * 开始标记和结束标记全部可以省略  
   是指该元素可以完全被省略。  
   注意，即使标记被省略了，该元素还是以隐式的方式存在的。  
      * html
      * head
      * body  
        例如省略不写body元素时，在文档结构中它还是存在的，可以使用document.body访问。
      * colgroup
      * tbody

2.具有boolean值的属性  
对于具有boolean值的属性，例如disabled与readonly等，
* 要想将属性值设定为true时
   * 只写属性不写属性值   
	`<input type="checkbox" checked>`
   * 属性值= 属性名  
	`<input type="checkbox" checked="checked">`
   * 属性值= 空字符串   
	`<input type="checkbox" checked="">`
* 要想将属性值设定为false时  
   * 不写属性   
	`<input type="checkbox" >`
    
3.省略引号  
* 在指定属性值的时候，属性值两边加引号时既可以用双引号，也可以用单引号。  
`<input type="text">`  
`<input type='text'>`  
* HTML 5在此基础上做了一些改进，当属性值不包括空字符串、“<”、“>”、“=”、单引号、双引号等字符时，属性值两边的引号可以省略。  
`<input type=text>`  



> [Vue.js快跑：构建触手可及的高性能Web应用](https://weread.qq.com/web/reader/82032410718487828207501kc81322c012c81e728d9d180)

## 第2章 Vue.js组件                                                           
* Vue.js允许并鼓励你将代码拆分为多个可在代码库中复用的组件。                                                            
这一章将详细阐述如何创建一个易于维护和理解的代码库。                                                            
* 那么什么是组件呢？                                                           
  * 组件是一段独立的、代表了页面的一个部分的代码片段。                                                         
  * 它拥有自己的数据、JavaScript脚本，以及样式标签。                                                         
  * 组件可以包含其他的组件，并且它们之间可以相互通信。                                                         
  * 组件可以是按钮或者图标这样很小的元素，                                                         
  也可以是一个更大的元素，比如在整个网站或者整个页面上重复使用的表单。                                                          
* 将代码从页面中分离到组件中的主要优势是，                                                            
  * 负责页面每一部分的代码都很靠近该组件中的其余代码。                                                         
  因此当你想要知道哪个元素有添加事件监听器，不必再在一堆JavaScript文件中搜索相应的选择器，因为JavaScript代码就在对应的HTML旁边！                                                         
  * 而且由于组件是独立的，还可以确保组件中的代码不会影响任何其他组件或产生任何副作用。                                                         
                                                            
### 组件基础
编写组件                                                            
1. 用对象语法定义组件                                                            
使用Vue.component()编写组件或是将它们作为对象存储可能会有点混乱，特别是处理更加复杂的组件时，你肯定不想在组件的template属性中编写大量的HTML代码。                                                            
  * 也可以注册一个全局的组件，只需像下面这样调用Vue.component()方法
    ```javascript
    Vue.component('custom-button', {                                                        
      template: '<button>自定义按钮</button>'                                                      
    });                          
    ```                             
    然后就可以在模板中使用这个组件了，和前面示例中的使用方式相同，                                                       
    但是你不需要在components配置对象中指定它了，它现在随处可用。                                                       
  * 可以通过components配置对象，将这个组件传入你的app
    ```javascript         
    <div id="app">                                                        
      <custom-button></custom-button>                                                     
    </div>                                                        
    <script>                                                        
      const CustomButton = {                                                      
        template: '<buttonn>自定义按钮</button>'                                                   
      };                                                      
      new Vue({                                                     
        el: '#app',                                                   
        components: {                                                   
          CustomButton                                                  
        }                                                   
      });                                                     
    </script> 
    ```                                                      
2. vue-loader和.vue文件                                                            
  vue-loader提供了一种方法，可以在.vue文件中以有条理并且易于理解的语法编写基于单个文件的组件。                                                         
  如果vue-loader已经设置好了，你就可以对这个前面出现过的组件进行处理：
  ```javascript
  Vue.component('display-number', {                                                         
    template: '<p>当前数字是{{ number }}</p>',                                                       
    props: {                                                        
      number: {                                                     
        type: Number,                                                   
        required: true                                                    
      }                                                     
    }                                                       
  });      
  ```                                                   
  把它修改成这样： 
  ```html                                                         
  // display-number.vue                                                         
  <template>                                                          
    <p>当前数字是{{ number }}</p>                                                        
  </template>                                                         
  <script>                                                          
    export default {                                                        
      props: {                                                      
        number: {                                                   
          type: Number,                                                 
          required: true                                                  
        }                                                   
      }                                                     
    };                                                        
  </script> 
  ```                                                        
  可以将其导入到应用中并使用它，就好像你用对象语法定义了它一样：
  ```html                                                         
  <div id="app">                                                          
    <display-number></display-number>                                                       
  </div>                                                          
  <script>                                                          
    import DisplayNumber from './components/display-number.vue';                                                        
    new Vue({                                                       
      components: {                                                     
        DisplayNumber                                                   
      }                                                     
    });                                                       
  </script>  
  ```                                                       
  经过webpack和vue-loader处理后，上面的代码的执行效果就和之前示例中的display-number组件一样。你必须使用预处理器，因为它无法直接在浏览器中工作。                                                          
  将组件分离到文件可以让你的代码更加容易维护。                                                          
  可以不必将所有的组件放在同一个大文件中，而是将它们分别保存在几个文件中，并放在相关名称的目录下，同时以它们所在的网站部分来命名，或者以组件的类型或规模来命名。                                                         
                                                            
### 数据、方法和计算属性
* 每个组件可以拥有它们自己的数据、方法和计算属性，以及所有在前面章节中出现过的属性——就像Vue实例一样。
* 定义组件的对象与我们用来定义Vue实例的对象相似，它们在很多地方可以互用。  
定义并注册一个包含数据和计算属性的全局组件：

```javascript                                                            
Vue.component('positive-numbers', {                                                           
  template: '<p>有{{ positiveNumbers.length }}个正数</p>',                                                          
  data() {                                                          
                                                            
                                                            
    return {                                                        
      numbers: [-5, 0, 2, -1, 1, 0.5]                                                     
    };                                                        
  },                                                          
  computed: {                                                         
    positiveNumbers() {                                                       
      return this.numbers.filter((number) => number >= 0);                                                      
    }                                                       
  }                                                         
});   
```    

  * 然后就可以在Vue模板的任何地方，通过<positive-numbers></positive-numbers>标签来使用这个组件。 
  *  Vue实例中的data属性是一个对象，然而组件中的data属性是一个函数。 
    * 这是因为一个组件可以在同一个页面上被多次引用，你大概不希望它们共享一个data对象 
    (因为同一个组件的每个实例的data属性是同一个对象的引用，当该组件的某个实例修改了自身的data属性，相当于所有实例的data属性都被修改了)                                                        
    * 所以组件的data属性应该是一个函数，在组件初始化时Vue会调用这个函数来生成data对象。 
    如果忘记将组件的data属性设置为函数，Vue会抛出一个警告。        
                                                            
### 传递数据
组件很有用，但当你开始传递数据到它内部时，组件才真正地展示出力量。                                                           
1. 可以使用props属性来传递数据                                                           
    1. Props是通过HTML属性传入组件的                                                          
    color="red"                                                         
      * 传递一个的简单数组，来表明组件可以接收的属性的名称
      ```html
      <div id="app">                                                      
        <color-preview color="red"></color-preview>                                                   
        <color-preview color="blue"></color-preview>                                                    
      </div>                                                      
      <script>                                                      
        Vue.component('color-preview', {                                                    
          template: '<div class="color-preview" :style="style"></div>',                                                 
          props: ['color'],                                                 
          computed: {                                                 
            style() {                                        
              return { backgroundColor: this.color };                                             
            }                                               
          }                                                 
        });                                                   
        new Vue({                                                   
          el: '#app',                                                 
        });                                                   
      </script> 
      ``` 
      以上示例代码会输出如下HTML片段： 
      ```html                                                     
      <div id="app">                                                    
        <div class="color-preview" style="background-color: red"></div>                                                 
        <div class="color-preview" style="background-color: blue"></div>                                                  
      </div>        
      ```                                            
      * 也可以传递一个对象，                                                        
          * 来描述属性的信息，                                                     
            * 比如它的类型、                                                   
            * 是否必须、                                                   
            * 默认值                                                   
            * 用于高级验证的自定义验证函数。                                                   
          * 要指定一个prop的类型，                                                     
            * 可以为它传递一个原生的构造函数，例如Number、 String或者Object
              ```javascript
              Vue.component('price-display', {                                                  
                props: {                                                
                  price: Number,                                              
                  unit: String                                              
                }                                               
              });                        
              ```                         
              如果price不是一个数字，或者unit不是一个字符串，Vue就会抛出一个警告。                                                  
              * 如果一个prop可以是多个类型中的一个，                                                  
              你就可以为它传递一个包含所有有效类型的数组，                                                  
              例如price: [Number, String, Price]                                                  
              （这里的Price是一个自定义的构造函数）。                                                  
            * 也可以指定一个prop是否是必需的，或者在没有传入值时，给它设定一个默认值。                                                  
            为此，可以传递给它一个对象而不是像前面那样的构造函数，并通过该对象的type属性来设置prop的类型：
              ```javascript
              Vue.component('price-display', {                                                
                props: {                                              
                  price: {                                            
                    type: Number,                                         
                    required: true                                          
                  },                                            
                  unit: {                                           
                    type: String,                                         
                    default: '$'                                          
                  }                                           
                }                                             
              })                          
              ```                      
              * price是一个必需的prop，如果没有传递值给它，就会抛出警告。                                               
              * unit不是必需的，但是有个默认值$，如果你没有传入任何值，在component内this.unit将会等于$                                               
            * 可以传递一个验证函数，                                                 
            该函数以prop的值为参数，在prop有效时应该返回true，而无效时则返回false。
              ```javascript
              price: {                                                
                type: Number,                                             
                required: true,                                             
                validator(value) {                                              
                  return value >= 0;                                            
                }                                             
              }          
              ```                                     
              验证了price是否大于零，这样你就不会在无意间为商品设置一个负数的价格                                                  
    2. 之后在组件内部，props属性的值表示可以传入组件的属性的名称                                                          
    这个例子中，就只有color。                                                         
    3. 然后，在组件内部就可以通过this.color来获取属性的值了。

  * Prop的大小写                                                            
  Vue都为我们处理好了。                                                            
  在HTML中通过kebab形式指定的属性，会在组件内部自动转换为camel形式：  
    ```html  
    <div id="app">                                                          
      <price-display percentage-discount="20%"></price-display>                                                       
    </div>                                                          
    <script>                                                          
      Vue.component('price-display', {                                                        
        props: {                                                      
          percentageDiscount: Number                                                    
        }                                                     
      });                                                       
      new Vue({                                                       
        el: '#app'                                                      
      });                                                       
    </script>                       
    ```                                  
                                                              
  * 响应式                                                           
    * 对于data对象、方法还有计算属性，当它们的值发生变化时，模板也会更新；                                                          
    * 同样，props也是这样的                                                         
      * 在父级实例中设定prop的值时，可以使用v-bind指令将该prop与某个值绑定。                                                       
      那么无论何时只要这个值发生变化，在组件内任何使用该prop的地方都会更新。                                                       
      如果prop的值不是字符串，那么就必须使用v-bind指令。                                                        
        * 比如下面的示例代码会抛出一个警告：                                                     
          <display-number number="10"></display-number>                             // 会抛出一个警告                      
          * 因为传递给number的是一个字符串，而不是数字。                                                   
          * 如果要传入一个数字，就要使用v-bind指令，                                                   
            * 它会把传入的值当作表达式求值，                                                 
            * 然后再传递给prop                                                  
    * 举个简单例子                                                          
      * 创建一个组件，它会显示设置在某个属性上的数字
        ```javascript             
        Vue.component('display-number', {                                                     
          template: '<p>当前数字是{{ number }}</p>',                                                   
          props: {                                                    
            number: {                                                 
              type: Number,                                               
              required: true                                                
            }                                                 
          }                                                   
        });            
        ```                                         
      * 然后将这个组件显示到页面，同时将它的值每秒加1：
        ```html             
        <div id="app">                                                      
          <display-number v-bind:number="number"></display-number>                                      // 如果prop的值不是字符串，那么就必须使用v-bind指令              
        </div>                                                      
        <script>                                                      
          new Vue({                                                   
            el: '#app',                                                 
            data: {                                                 
              number: 0                                               
            },                                                  
            created() {       // created函数在实例创建后执行                                          
              setInterval(() => {                                               
                this.number++;                                              
              }, 1000);                                               
            }                                                 
          });                                                   
        </script>       
        ```                                              
        传递给display-number的数字会每秒增加1，于是对应的prop也会每秒变化一次。                                                     
                                                              
  * 数据流和.sync修饰符                                                            
    * 数据通过prop从父级组件传递到子组件中，当父级组件中的数据更新时，传递给子组件的prop也会更新。                                                          
    但是你不可以在子组件中修改prop。                                                          
    这就是所谓的单向下行绑定，防止子组件在无意中改变父级组件的状态。                                                          
    * 如果想要使用双向绑定，可以使用一个修饰符来实现：.sync修饰符。                                                         
      * 它只是一个语法糖                
      ```javascript                                        
      <count-from-number :number.sync="numberToDisplay" />                           
      ```                             
      上面的代码等效于：         
      ```javascript                                              
      <count-from-number :number="numberToDisplay" @update:number="val => numberToDisplay = val" />      
      ```                                                 
      如果想要更改父级组件的值，需要触发update:number事件，该指令的参数——示例中为number——是将要更新的值的名称                                                       
      1. 通过触发事件来改变值                                                       
        如何实现一个CountFromNumber组件，它获取一个初始值并开始计数，同时更新父级组件的值：
        ```javascript
        Vue.component('count-from-number', {                                                      
          template: '<p>当前数字是{{ number }}</p>',                                                   
          props: {                                                    
            number: {                                                 
              type: Number,                                               
              required: true                                                
            }                                                 
          },                                                    
          mounted() {                                                   
            setInterval(() => {                                                 
              this.$emit('update:number', this.number + 1);                                               
            }, 1000);                                                 
          }                                                   
        });             
        ```                                        
        组件内部的值根本就不会变化，但是它改变了父级组件的值，这个值会通过prop传递回子组件。                                                      
      2. 使用计算属性来改变值                                                       
      在某些情况下，将触发事件的逻辑封装到计算属性中会有利于代码的组织
        ```javascript 
        Vue.component('count-from-number', {                                                      
          template: '<p>当前数字是{{ localNumber }}</p>',                                                    
          props: {                                                    
            number: {                                                 
              type: Number,                                               
              required: true                                                
            }                                                 
          },                                                    
          computed: {                                                   
            localNumber: {                                                  
              get() {                                               
                return this.number                                              
              },                                                
              set(value) {                                                
                this.$emit('update:number', value);                                             
              }                                               
            }                                                 
          },                                                    
          mounted() {                                                   
            setInterval(() => {                                                 
              this.localNumber++;                                               
            }, 1000);                                                 
          }                                                   
        });   
        ```                                                  
          * localNumber在效果上等同于number。                                                   
            * 它获取prop的值                                                 
            * 并且为localNumber设置新的值时，会触发事件来更新父级组件的值（父级组件中更新后的值会再次传递到子组件中）                                                 
          * 需要注意的是，这样有可能引发无限循环：                                                   
          如果父级组件与子组件都对同一个值的更新做出反应，并且在处理更新的过程中再次改变这个值，这会让你的应用程序出现问题！                                                   
    * 如果仅仅想要更新从prop传入的值，而不关心父级组件的值的更新，你可以在一开始的data函数中通过this来引用prop的值，将它复制到data对象中     
      ```javascript                                                    
      Vue.componet('count-from-number', {                                                       
        template: '<p>当前数字是{{ number }}</p>',                                                     
        porps: {                                                      
          initialNumber: {                                                    
            type: Number,                                                 
            required: true                                                  
          }                                                   
        },                                                      
        data() {                                                      
          return {                                                    
            number: this.initialNumber                                                  
          }                                                   
        },                                                      
        mounted() {                                                     
          setInterval(() => {                                                   
            this.number++;                                                  
          }, 1000);                                                   
        }                                                     
      });         
      ```                                              
        * 需要注意的是，如果prop的值更新了，组件内部并不会更新，因为它引用的是另外一个值。                                                      
        * 如果你想要根据新提供的数值重新开始计数，可以为initialNumber添加一个侦听器，将新的值复制给number。                                                      
                                                                
  * 自定义输入组件与v-model                                                           
  与.sync修饰符相似，可以在组件上使用v-model指令来创建自定义输入组件。                                                            
    * 这里同样也是一个语法糖             
      ```html                                            
      <input-username v-model="username" />          
      ```                                             
      上面的代码等效于：         
      ```html                                              
      <input-username :value="username" @input="value => username = value" />                                                       
      ```
    * 为了创建InputUsername组件，我们需要它做两件事情：                                                         
      1. 首先，它需要通过value属性获取初始值，                                                        
      2. 然后不论何时，只要value的值发生变化，它必须触发一个input事件。                                                       
      在这个例子中，我们要让组件将value的值转化为小写形式，再通过事件将它传递出去。                                                       
        * 在之前例子中使用的方法（通过触发事件来改变值或使用计算属性）将不再有效。                                                      
        * 这里，必须监听输入框元素的input事件         
        ```javascript                                             
        Vue.component('input-username', {                                                     
          template: '<input type="text" :value="value" @input="handleInput">',                                                    
          props: {                                                    
            value: {                                                  
              type: String,                                               
              required: true                                                
            }                                                 
          },                                                    
          methods: {                                                    
            handleInput(e) {                                                  
              const value = e.target.value.toLowerCase();                                               
              // 如果value发生变化，input的值也要更新                                                
              if(value != e.target.value) {                                               
                e.target.value = value;                                             
              }                                               
              this.$emit('input', value);                                               
            }                                                 
          }                                                   
        });         
        ```                                            
        * 现在可以像使用input元素一样使用这个组件了，v-model的用法还是不变。                                                     
        * 唯一的区别是无法输入大写字母！                                                     
          * 上面的示例存在一个问题：如果输入一个大写字母，光标会移动到文字的末尾。这在第一次输入内容时并不会有什么问题。但是如果回退光标去修改内容，光标将会出现跳动。                                                   
          这是一个很容易解决的问题，                                                   
          只需在设置e.target.value的值之前，保存当前光标的位置，                                                    
          在做出修改之后，再次设置光标的位置。
2. 使用插槽（slot）将内容传递给组件                                                           
    * 除了将数据作为prop传入到组件中，Vue也允许传入HTML。                                                           
    * 不仅可以传入字符串                                                         
      * 假如想要创建一个自定义按钮元素，                                                        
        * 你可能会通过一个属性来设置按钮的文本   
          ```html                                                   
          <custom-button text="单击我！"></custom-button>  
          ```                                                 
        * 不过下面这种方式会更加自然：  
          ```html                                                    
          <custom-button>单击我！</custom-button>   
          ```                                                
          * 要在组件中使用这个文本内容，可以像下面这样使用<slot>标签：
            ```javascript                                                    
            Vue.component('custom-button', {                                                  
              template: '<button class="custom-button"><slot></slot></button>'                                                
            })
            ```                                                  
          这样会生成如下HTML片段： 
            ```html                                                   
            <button class="custom-button">单击我！</button>       
            ```                                          
    * 也可以传入任何你想要的HTML，甚至是其他的Vue组件                                                         
      * 这样可以创建复杂的页面，而不至于让组件的体积变得过于庞大。                                                       
      可以把页面分割为一个头部组件、一个侧边栏组件和一个内容组件                                                       
      模板可以像下面这样：  
        ```html                                                      
        <div class="app">                                                     
          <site-header></site-header>                                                   
          <div class="container">                                                   
            <site-sidebar>                                                  
              ...这里是侧边栏的内容...                                               
            </site-sidebar>                                                 
            <site-main>                                                 
              ...这里是正文的内容...                                                
            </site-main>                                                  
          </div>                                                    
        </div>  
        ```                                                    
      这是一个构建网站的好方法，特别是当你开始使用局部CSS和vue-router时                                                       
                                                              
    * 默认内容                                                            
    如果为<slot>元素设定了内容，那么该内容会在组件没有接收到内容时被当作默认内容使用。                                                            
    1. 单个插槽                                                         
    这可能是插槽最普遍的用法，当然也是最容易理解的：                                                          
    传递给组件的内容会替换掉它里面的<slot>元素输出到页面上。                                                         
    为<custom-button>组件设置一些文本作为默认内容：                                                         
      * template属性只在非常简单的例子中才显得有用。
        ```javascript                                                        
        Vue.component('custom-button', {                                                      
          template: '<button class="custom-button"><slot><span class="default-text">默认的按钮文本</span></slot></button>'                                                   
                                                              
        });  
        ```                                                   
      * 在“vue-loader与.vue文件”一节中，将会讲到如何将HTML代码从组件对象中分离出去。                                                        
      在template的字符串中编写HTML会显得笨重，所以再来看看这个例子，不过这次是在HTML代码中：
        ```html
        <button class="custom-button">                                                      
          <slot>                                                    
            <span class="default-text">默认的按钮文本</span>                                                 
          </slot>                                                   
        </button>                                        
        ```             
      <slot>元素內有默认的文本，而且文本还被一个有着default-text类名的span元素包裹着。                                                       
      这完全是可选的——没有必要将插槽元素中的内容或是默认内容用其他元素包裹起来；                                                        
      你可以使用任何你想要的HTML内容。                                                        
                                                              
    2. 具名插槽                                                         
    具名插槽具有一个名称，它允许你在同一个组件中拥有多个插槽。

      * 假设，有一个简单的博文组件，它有一个头部（通常是一个标题，但也可能是其他东西）和一些文本。                                                       
        * 这个组件的模板可以是下面这样的： 
          ```html                                                     
          <section class="blog-post">                                                   
            <header>                                                  
              <slot name="header"></slot>                                               
              <p>作者{{ author.name }}</p>                                                
            </header>                                                 
            <main>                                                  
              <slot></slot>                                               
            </main>                                                 
          </section>      
          ```                                              
        一个不带 name 的 <slot> 出口会带有隐含的名字“default”。                                                     
        * 然后在模板中引用这个组件时，                                                      
                                                              
          * 在向具名插槽提供内容的时候，我们可以在一个 <template> 元素上使用 v-slot 指令，并以 v-slot 的参数的形式提供其名称                                                    
          注意 v-slot 只能添加在 <template> 上 (只有一种例外情况)，这一点和已经废弃的 slot attribute 不同。
          ```html
          <blog-post :author="author">                                                    
            <template v-slot:header>博文的标题</template>                                                  
            <template v-slot:default>                                                 
              <p>博文的内容</p>                                                
              <p>更多内容</p>                                               
            </template>                                                 
          </blog-post>                         
          ```                           
            * 现在 <template> 元素中的所有内容都将会被传入相应的插槽。                                                  
            * 任何没有被包裹在带有 v-slot 的 <template> 中的内容都会被视为默认插槽的内容。                                                  
                                                              
          * 自 2.6.0 起有所更新。已废弃的使用 slot attribute 的语法                                                   
          ~~可以使用slot属性来指定某个元素应该被插入名为header的插槽，而其他的HTML将被插入未命名的插槽：~~. 
          ~~`<blog-post :author="author">`~~ 
            ~~`<h2 slot="header">博文的标题</h2>`~~ 
            ~~`<p>博文的内容</p>`~~ 
            ~~`<p>更多内容</p>`~~ 
          ~~`</blog-post>`~~ 
          ~~生成的HTML看起来会是下面这样的：~~ 
          ~~`<section>`~~ 
            ~~`<header>`~~ 
              ~~`<h2>博文的标题</h2>`~~ 
              ~~`<p>作者Callum Macrae</p>`~~ 
            ~~`</header>`~~ 
            ~~`<main>`~~ 
              ~~`<p>博文的内容</p>`~~ 
              ~~`<p>更多内容</p>`~~ 
            ~~`</main>`~~ 
          ~~`</section>`~~. 
                                                              
    3. 作用域插槽                                                          
      [vue.js官网](https://cn.vuejs.org/v2/guide/components-slots.html#%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%8F%92%E6%A7%BD)                                                       
      * 可以将数据传回slot组件，使父组件中的元素可以访问子组件中的数据。                                                        
        * 创建一个获取用户信息的组件，而数据的显示则留给父级元素来处理：                                                     
        为了让 user 在父级的插槽内容中可用，我们可以将 user 作为 <slot> 元素的一个 attribute 绑定上去                                                      
        绑定在 <slot> 元素上的 attribute 被称为插槽 prop。
        ```javascript     
        Vue.component('user-data', {                                                      
          template: '<div class="user"><slot :user="user"></slot></div>',                                                   
          data: () => ({                                                    
            user: undefined,                                                  
          }),                                                   
          mounted() {                                                   
            // 设置this.user...                                                 
          }                                                   
        }); 
        ```                                                    
        * 引用这个组件，并用自己编写HMTL来显示用户信息：                                                     
          * 现在在父级作用域中，我们可以使用带值的 v-slot 来定义我们提供的插槽 prop 的名字：
          ```html
          <div>                                                   
            <user-data v-slot:default="slotProps">                                                  
              <p v-if="user">用户名：{{ slotProps.user.name }}</p>                                                
            </user-data>                                                  
          </div>                       
          ```                             
          *  自 2.6.0 起有所更新。已废弃的使用 slot-scope attribute 的语法. 
          ~~`任何传递给<slot>的属性都可以用slot-scope属性中定义的变量来获取。`~~
          ~~`<div>`~~                                                   
            ~~`<user-data slot-scope="user">`~~                                                 
              ~~`<p v-if="user">用户名：{{ user.name }}</p>`~~ 
            ~~`</user-data>`~~                                                  
          ~~`</div>`~~                         
      * 独占默认插槽的缩写语法                                                       
        * 当被提供的内容只有默认插槽时，组件的标签才可以被当作插槽的模板来使用。                                                     
        这样我们就可以把 v-slot 直接用在组件上： 
          ```html                                                     
          <current-user v-slot:default="slotProps">                                                   
            {{ slotProps.user.firstName }}                                                  
          </current-user>     
          ```                                              
                                                              
        * 就像假定未指明的内容对应默认插槽一样，不带参数的 v-slot 被假定对应默认插槽：
          ```html
          <current-user v-slot="slotProps">                                                   
            {{ slotProps.user.firstName }}                                                  
          </current-user>              
          ```                                     
                                                              
        * 注意默认插槽的缩写语法不能和具名插槽混用，因为它会导致作用域不明确：
          ```html
          <!-- 无效，会导致警告 -->                                                   
          <current-user v-slot="slotProps">                                                   
             {{ slotProps.user.firstName }}                                                 
              <template v-slot:other="otherSlotProps">                                                  
                slotProps is NOT available here                                                 
              </template>                                                 
          </current-user>     
          ```                                              
        * 只要出现多个插槽，请始终为所有的插槽使用完整的基于 <template> 的语法：
          ```html
          <current-user>                                                    
            <template v-slot:default="slotProps">                                                 
            {{ slotProps.user.firstName }}                                                  
            </template>                                                 
                                                              
            <template v-slot:other="otherSlotProps">                                                  
              ...                                               
            </template>                                                 
          </current-user>            
          ```                                       
                                                              
      * 作用域插槽与具名插槽组合在一起，用来覆盖元素的样式会很有用。                                                        
        * 看一个显示文章摘要列表的组件： 
        ```html                                                    
        <div>                                                     
          <div v-for="post in posts">                                                   
            <h1>{{ post.title }}</h1>                                                 
            <p>{{ post.summary }}</p>                                                 
          </div>                                                    
        </div>      
        ```                                                
        它接收一个文章数组变量posts，然后输出所有的文章标题和摘要                                                     
        可以这样使用它：
        ```html                                                      
        <blog-listing :posts="posts"></blog-listing>   
        ```                                                   
        * 创建该组件的另一个版本。                                                      
          在这个版本中，可以传入自己的HTML，用来显示文章的摘要——或许，举个例子，也有可能我们只想在页面上显示图片。                                                   
          那么在具名插槽元素中，就需要用一个段落元素将摘要信息包裹起来，之后只要愿意，就可以覆盖掉它。
          ```html
          <div>                                                   
            <div v-for="post in posts">                                                 
              <h1>{{ post.title }}</h1>                                               
              <slot name="summary" :post="post">                                                
                <p>{{ post.summary }}</p>                                             
              </slot>                                               
            </div>                                                  
          </div>                         
          ```                           
          * 我们原来使用该组件的方式仍然有效，                                                   
          因为即使没有提供插槽元素，段落元素作为默认的内容仍然可以使用。                                                   
          * 但是如果愿意，可以覆盖掉摘要信息。 
            ```html                                                  
            <blog-listing :posts="posts">                                                 
              <template v-slot:summary="slotProps">                                               
                <img :src="post.image" :alt="post.summary">                                             
              </template>                                               
            </blog-listing>                                                 
            <blog-listing :posts="posts">                                                 
              <img                                                
                slot="summary"                                              
                slot-scope="post"                                             
                :src="post.image"                                             
                :alt="post.summary">                                              
            </blog-listing>     
            ```                                            
            现在文本元素就被图片元素替换了                                                 
            不过我们将文章的摘要作为图片的备用文字。这点很重要，它让使用屏幕阅读器等辅助技术的用户仍然可以读到文章的内容。                                                 
                                                              
      * 插槽作用域解构                                                       
      v-slot 的值实际上可以是任何能够作为函数定义中的参数的 JavaScript 表达式。                                                        
        * 所以在支持的环境下 (单文件组件或现代浏览器)，你也可以使用 ES2015 解构来传入具体的插槽 prop                                                     
        这样可以使模板更简洁，尤其是在该插槽提供了多个 prop 的时候。
          ```html
          <current-user v-slot="{ user }">                                                    
          {{ user.firstName }}                                                    
          </current-user>            
          ```                                       
        * 它同样开启了 prop 重命名等其它可能，例如将 user 重命名为 person：

          ```html
          <current-user v-slot="{ user: person }">                                                    
          {{ person.firstName }}                                                    
          </current-user> 
          ```
        * 你甚至可以定义后备内容，用于插槽 prop 是 undefined 的情形
          ```html                                                   
          <current-user v-slot="{ user = { firstName: 'Guest' } }">                                                   
          {{ user.firstName }}                                                    
          </current-user>      
          ```                                             
      作为一种简写方式，你可以解构slot-scope的属性，就像解构函数参数一样。                                                       
      用解构重写前面的例子：    
        ```html                                                   
        <blog-listing>                                                      
          <img                                                    
            slot="summary"                                                  
            slot-scope="{ image, summary }"                                                 
            :src="image"                                                  
            :alt="summary">                                                 
        </blog-listing>   
        ```

### 自定义事件
* 除了可以处理原生DOM事件，v-on指令也可以处理组件内部触发的自定义事件。 
  * 调用this.$emit()函数可以触发一个自定义事件，                 
    * 它接收一个事件名称以及其他任何你想要传递的参数。              
  * 然后就可以使用组件上的v-on指令来监听这个事件了。               
* 一个简单的组件，                                                            
  * 每次被单击时，它都会触发一个叫作count的事件：                 
  每次按钮被单击时，它都会触发count事件，参数为被单击的次数。
    ```html        
    <div id="app">                                                        
      <button @click="handleClick">单击了{{ clicks }}次</button>                                                      
    </div>                                                        
    <script>                                                        
      new Vue({                                                     
        el: '#app',                                                   
        data: () => ({                                                    
          clicks: 0                                                 
        }),                                                   
        methods: {                                                    
          handleClick() {                                                 
            this.clicks++;                                                
            this.$emit('count', this.clicks);                                               
          }                                                 
        }                                                   
      });                                                     
    </script>  
    ```                                                     
  * 之后我们使用这个组件时，可以使用v-on指令来监听这个自定义事件，就和使用v-on指令监听click事件一样。                                                         
  下面的示例将接收counter组件中通过事件传递的数字并显示在页面上：
    ```html   
    <div id="app">                                                        
      <counter v-on:count="handleCount"></counter>                                                      
      <p>单击次数 = {{ clicks }}</p>                                                      
    </div>                                                        
    <script>                                                        
      const Counter = {                                                     
        // 这里是组件的定义                                                   
      }                                                     
      new Vue({                                                     
        el: '#app',                                                   
        data: {                                                   
          clicks: 0                                                 
        },                                                    
        methods: {                                                    
          handleCount(clicks) {                                                 
            this.clicks = clicks;                                               
          }                                                 
        },                                                    
        components: {                                                   
          Counter                                                 
        }                                                   
      });                                                     
    </script>        
    ```                                               
                                                            
* 处理事件的方法：                                                            
  1. $on                                                          
  在组件内部代码中，还可以使用$on方法来监听组件自身触发的事件。                                                          
    * 它和任何事件分发器（event dispatcher）的工作原理几乎相同：                                                       
    当使用$emit方法触发一个事件，通过$on方法添加的事件处理函数就会执行。                                                        
      * 监听当前实例上的自定义事件。                                                      
      * 事件可以由 vm.$emit 触发。                                                      
      * 回调函数会接收所有传入事件触发函数的额外参数。
        ```javascript           
        vm.$on('test', function (msg) {                                                   
        console.log(msg)                                                    
        })                                                    
        vm.$emit('test', 'hi')                                                    
        // => "hi"   
        ```                                                 
    * 监听子组件触发的事件                                                        
      * 不过不能使用this.$on方法监听子组件触发的事件；                                                     
      * 如果这么做，                                                      
        * 可以在组件上使用v-on指令，                                                   
        * 或者可以使用组件上的ref属性来调用子组件自身的.$on方法
        ```html   
        <div id="app">                                                    
          <counter ref="counter"></counter>                                                 
        </div>                                                    
        <script>                                                    
          // 为了简单起见，该组件没有写完整                                                  
          new Vue({                                                 
            el: '#app',                                               
            mounted() {                                               
              this.$refs.counter.$on('count', this.handleCount);                                              
            }                                               
          });                                                 
        </script>    
        ```                                               
  2. $once                                                          
  $once的行为和$on一样，但绑定的监听器只会执行一次——在事件第一次被触发时                                                          
  3. $off                                                         
  $off方法则用于移除一个事件监听器                                                          
                                                            
* **事件触发器**（eventemitter）：                                                            
  * Node.js里的EventEmitter模块                                                         
  * jQuery中的.on()、.once()、.off()和.trigger()                                                         
  * 由于Vue内置了完整的**事件触发器**，当你使用Vue时，不需要再引入自己的**事件触发器**了。                                                          
  甚至在开发Vue组件的局部代码时也可以利用Vue的**事件触发器**，只需要用newVue()创建一个实例。
    ```javascript
    const event = new Vue();                                                        
    let count = 0;                                                        
    function logCount() {                                                       
      count++;                                                      
      console.log(`调试函数执行了 ${count} 次`);                                                      
    }                                                       
                                                            
    event.$on('test-event', logCount);                                                        
                                                            
    setInterval(() => {                                                       
      events.$emit('test-event');               // 这段代码每秒会向控制台输出记录                                      
    }, 1000);                                                       
                                                            
    setTimeout(() => {                                                        
      events.$off('test-event');              // 直到10s后.off()方法将事件处理函数移除时终止                                       
    }, 10000);  
    ```                                                      
    这在处理基于Vue的代码与非Vue的代码之间的通信时，极为有用                                                       
    但总的来说，只要情况允许，vuex往往是更好的选择。                                                        
                                                            
### 混入
混入是一种代码组织方式，可以在多个组件间横向复用代码。                                                           
* 例如，假设你有许多用于显示不同类型用户的组件。虽然大部分显示的信息都依赖于用户的类别，但是组件间相当多的逻辑代码是共同的。                                                           
有3种处理方式：                                                            
  1. 为所有的组件编写重复的代码（很明显这不是一个好主意）                                                         
  2. 将共同的代码分离到多个函数中，并存储到util文件里                                                         
  3. 使用混入                                                         
  后两种方式在这个例子中很相似，但是使用混入是一种更加符合Vue习惯的处理方式——在即将介绍的其他诸多示例中，它会更加有用。                                                         
    * 只要将混入对象添加到组件中，那么该组件就可以获取到存储在混入对象中的任何东西。                                                       
      1. 混入方法                                                     
      让我们创建一个混入对象，它会为所在的组件添加一个getUserInformation()方法：
        ```javascript
        const userMixin = {                                                   
          methods: {                                                  
            getUserInformation() {                                                
              return fetch(`/api/user/${userId}`)                                             
                    .then((res) => res.json());                                       
            }                                               
          }                                                 
        };         
        ```                                           
      把它添加到一个组件中并使用它： 
        ```javascript                                                    
        import userMixin from './mixins/user';                                                    
        Vue.component('usr-admin', {                                                    
          mixins: [userMixin],                                                  
          template: '<div v-if="user">姓名：{{ user.name }}</div>,                                                 
          props: {                                                  
            userId: {                                               
              type: Number                                              
            }                                               
          },                                                  
          data: () => ({                                                  
            user: undefined                                               
          }),                                                 
          mounted() {                                                 
            this.getUserInfomation(this.userId)                             //                  
                .then((user) => {                                           
                  this.user = user;                                         
                });                                           
          }                                                 
        });    
        ```                                               
        Vue已经自动将该方法添加到组件中去了——或者说该方法被“混入”组件內了。                                                   
      2. 除了方法，混入对象可以引用几乎任何Vue组件所能引用的东西，就好像它是组件本身的一部分一样。                                                     
      我们来更改示例中的混入对象，让它可以处理数据的存储和mounted钩子
        ```javascript
        const userMixin = {                                                   
          data: () =>({                                                 
            user: undefined                                               
          }),                                                 
          mounted() {                                                 
            fetch(`/api/user/${this.userId}`)                                               
              .then((res) => res.json())                                              
              .then((user) => {                                             
                this.user = user;                                           
              });                                             
          }                                                 
        };  
        ```                                                  
        组件就可以简化为：  
        ```javascript                                                 
        import userMixin from './mixins/user';                                                    
        Vue.component('user-admin', {                                                   
          mixins: [userMixin],                                                  
          template: '<div v-if="user">姓名：{{ user.name }}</div>',                                                  
          props: {                                                  
            userId: {                                               
              type: Number                                              
            }                                               
          }                                                 
        });    
        ```                                               
        虽然混入使组件简化了很多，但是追踪数据的来源变得复杂了。                                                    
        当决定将哪些代码放在混入对象中，哪些代码放入组件中时，你必须衡量这样做的代价与收益。                                                    
* 混入对象和组件的合并                                                            
如果混入对象和组件间有重复的选项，根据它们的类型，Vue会分别对待。                                                            
比如它们都有一个叫作addUser()的方法或者都有一个created()钩子                                                           
  * 对于生命周期钩子——诸如created()和beforeMount()这样的——Vue会将它们添加到一个数组中并全部执行：
    ```javascript
    const loggingMixin = {                                                        
      created() {                                                     
        console.log('mixin中的记录');                                                   
      }                                                     
    };                                                        
    Vue.component('example-component', {                                                        
      mixins: [loggingMixin],                                                     
      created() {                                                     
        console.log('组件中的记录');                                                    
      }                                                     
    });        
    ```                                               
    当组件被创建时，“mixin中的记录”和“组件中的记录”都将会输出到控制台。                                                        
  * 对于重复的方法、计算属性或其他任何非生命周期钩子属性，组件中的属性会覆盖混入对象中的属性
    ```javascript
    const loggingMixin2 = {                                                       
      methods: {                                                      
        log() {                                                   
          console.log('mixin中的记录');                                                 
        }                                                   
      }                                                     
    };                                                        
    Vue.component('example-component', {                                                        
      mixins: [loggingMixin2],                                                      
      created() {                                                     
        this.log();                                                   
      },                                                      
      methods: {                                                      
        log() {                                                   
          console.log('组件中的记录');                                                  
        }                                                   
      }                                                     
    });            
    ```                                           
    当组件被创建时，只有“组件中的记录”会被输出，因为组件中的log()方法覆盖了混入中的log()方法。                                                       
      * 有时候我们有意使用这种合并方式，但也有时候却是碰巧在不同的地方定义了相同名称的方法，如果它们中的某个方法被覆盖，可能会引发一些问题！                                                      
      因此，官方的Vue代码风格指南建议对于混入中的私有属性（不应该在混入之外使用的方法、数据和计算属性），应该在它们的名称前面添加前缀。                                                      
      前面的混入对象的log()方法可以写成$_loggingMixin2_log()。                                                     
      这在开发插件时极为重要，因为用户有可能将你的插件添加到他们自己的代码中去。                                                     
                                                            
### 非Prop属性
* 如果为某个组件设置的属性并不是用作prop，该属性会被添加到组件的HTML**根元素**上。                                                            
这适用于任何HTML属性或特性，而不仅仅是class。                                                           
假设想要给前面的<display-number>组件添加一个class，你可以在引用该组件的地方为它添加class
  ```html
  <display-number class="some-class" :number="4"></display-number>           
  ```                                               
  以下为输出的结果：                  
  ```html                                       
  <p class="some-class">当前数字是4</p>    
  ```                                                      
* 如果我们为组件和组件的**根元素**设置相同的属性，会发生什么呢？                                                           
  * 大部分属性都像这样，会覆盖组件内部模板中的同名属性                                                         
  大多数时候，如果我们为两者设置了相同的属性，组件上的属性会覆盖它内部模板上的属性。
    ```html
    <div id="app">                                                        
      <custom-button type="submit">单击我!</custom-button>                                                     
    </div>                                                        
    <script>                                                        
      const CutomButton = {                                                     
        template: '<button type="button"><slot></slot></button>'                                  // 在我们的组件模板中，将按钮设置为type="button"                  
      };                                                      
      new Vue({                                                     
        el: '#app',                                                   
        components: {                                                   
          CustomButton                                                  
        }                                                   
      });                                                     
    </script>      
    ```                                                 
    在我们的组件模板中，将按钮设置为type="button"，                                                        
    但是在引用组件时，将它设置为type="submit"。                                                        
    设置在组件上的属性（而不是组件内部的属性）会覆盖掉另外的设置。                                                       
    以下为输出：          
    ```html                                              
    <buttonn type="submit">单击我！</button>    
    ```                                                    
                                                            
  * class和style稍微聪明一点，同名的值会被合并
    ```html                   
    <div id="app">                                                        
      <custom-button class="margin-top" style="font-weight: bold; background-color: red">                                                     
        单击我！                                                    
      </custom-button>                                                      
    </div>                                                        
    <script>                                                        
      const CustomButton = {                                                      
        template: `                                                   
          <button                                                 
            class="bustom-button"                                               
            style="color: yellow; background-color: blue"                                               
            <slot></slot>                                               
          </button>`                                                  
      };                                                      
      new Vue({                                                     
        el: '#app',                                                   
        components: {                                                   
          CustomButton                                                  
        }                                                   
      });                                                     
    </script>    
    ```                                                   
      * class将会被合并在一起变成custom-button margin-top                                                     
      * style属性则会被合并为color: yellow; background-color:red; font-weight: bold;                                                      
      组件属性中的background-color样式覆盖掉了内部模板中的background-color样式。                                                     
                                                            
### 组件和v-for指令
当使用v-for指令遍历一个数组或是对象，并且给定的数组或对象改变时，Vue不会再重复生成所有的元素，而是智能地找到需要更改的元素，并且只更改这些元素。                                                            
* 如果有一个作为列表元素输出到页面上的数组，在它的末尾添加一个新元素，那么页面上现有的元素将保持不变，同时在末尾，新的元素会被创建。                                                           
如果数组中间的一个元素改变了，则页面上只有对应的元素会更新。                                                            
* 如果你在数组的中间删除或是添加一个元素，Vue不会知道该元素对应的是页面上哪一个元素，它会更新从删除或是添加元素的位置到列表结尾之间的每一个元素。                                                           
对于复杂的内容和组件，你肯定不希望Vue这么做。                                                            
* 使用v-for指令时可以设置一个key属性，通过它可以告诉Vue数组中的每个元素应该与页面上哪个元素相关联，从而删除正确的元素。                                                            
key属性的值默认为元素在循环时的索引。                                                            
  * 可以通过下面的代码来了解这是如何工作的：
    ```html
    <template>                                                        
      <demo-key v-for="(item, i) in items" @click.native="items.splice(i, 1)".                                                      
        {{ item }}                                                    
      </demo-key>                                                     
    </template>                                                       
    <script>                                                        
      const randomColor = () => `hsl(${Math.floor(Math.random() * 360)}, 75%, 85%)`;                                                      
      const DemoKey = {                                                     
        template: `<p :style="{ backgroundColor: color }"><slot></slot></p>`,                                                   
        data: () => ({                                                    
          color: randomColor()                                                  
        })                                                    
      };                                                      
      export default {                                                      
        data: () => ({                                                    
          items: ['one', 'two', 'three', 'four', 'five']                                                  
        }),                                                   
        components: {                                                   
          DemoKey                                                 
        }                                                   
      };                                                      
    </script>       
    ```
    * click事件的处理函数是通过.native修饰符添加的，因为这就是为组件添加原生DOM事件监听器的方式。                                                       
    没有.native修饰符，事件处理函数将不会被调用。                                                        
  * 上面的示例会输出5个颜色随机的、包含数字1到5的段落元素


    * 单击其中的一个段落元素，会将对应的元素从items数组中删除。                                                       
    如果单击第二个段落元素——即图中标签为two的元素——希望那个元素会被彻底删除，然后标签为three的元素会变成第二个。                                                        
    * 实际上并不会这样！最终你得到的是下面这样的结果：

      * 这是Vue的差异对比机制引起的：                                                      
      删除了数组中的第二个元素，而原本的位置上将会变成第三个元素，于是Vue更新页面上对应元素的文本来反映变化，                                                     
      对于下个元素、下下个元素都是如此，一直到数组的结尾。                                                      
      最终它会删除最后一个元素。                                                     
      不过，这很可能并不是你想要的                                                      
  * 为这个示例添加一个key属性，来告诉Vue应该删除哪个元素：          
    <template>                                                        
      <demo-key v-for="(item, i) in items" :key="item" @click.native="items.splice(i, 1)">
        {{ item }}                                                    
      </demo-key>                                                     
    </template>                                                       
    key属性必须是一个唯一的数字或者字符串，并与数组中的元素相对应。                                                       
    * 我经常看到有人将key设置为数组的下标（例如在前面例子中设置:key="i"）。                                                        
    如果不是什么特殊情况，那么你不会想要这么做的！                                                       
    虽然Vue不会再发出警告，但你会遇到与我刚才向你展示的完全相同的问题，一个并非你期望的元素将被删除。                                                        
  * 现在，单击第二个元素将会把two从数组中删除，同时对应的元素也将被删除，结果如下：
    总之，无论什么情况，只要允许就应该设置一个key。                                                       
* 在组件中使用v-for指令时key属性并不是可选的，正如你在前面的示例中看到的，在那个示例中，Vue将会在控制台中显示一个警告。       

## 使用Vue添加样式
                              
如何在Vue中使用CSS来定制化网站和应用，以及使用内置的辅助函数来协助你完成这项工作。 
### Vue提供了几种方式来为网站或是应用添加样式
   v-bind:class和v-bind:style两者都有专门的功能，帮助你通过数据设置class属性和内联样式。                                 
#### Class绑定                             
   通常使用v-bind绑定class属性，从而可以根据数据的变化添加或删除类名。    
   在使用v-bind设置class属性时，Vue增加了一些简洁的用法，使之更加易于使用。  
   如果使用过React中的classNames工具，那么你将会非常熟悉v-bind语法。    
   v-bind与它基本相似，不同的是v-bind使用一个数组将类名包裹起来，而不是将类名作为函数的参数。                      
   
   如果不需要任何有关数组或是对象的功能                           
##### 将class设置为一个普通的字符串  
 ```html
 <div class="my-class"></div>  
 ```
##### 一个包含类名的变量     
 ```html
 <div :class="classNameVariable"></div>  
 ```      
##### 使用数组                          
如果传递一个数组给v-bind:class，数组中的类名将会被拼接到一起。                       
这在你想要根据数据或是计算属性设置class时非常方便。请看下面的示例：   
```html
  <div id="app">                      
     // div元素会得到一个值为foo bar的class属性                     
     <div v-bind:class="[firstClass, secondClass]">                    
        ...                  
     </div>                     
  </div>                        
  <script>                      
     new Vue({                     
        el: '#app',                
        data: {                 
           firstClass: 'foo'             
        },                
        computed: {                
           secondClass() {               
              return 'bar';           
           }              
        }                 
     });                     
  </script>         
```               
                      
##### 使用对象                          
* 对象会根据条件把它的键名作为class添加到元素上，这取决于键名所对应的值： 
 * 如果值为真，那么键名会作为class被添加                     
 * 否则，如果是假，就不会被添加                   
假如class绑定的对象为{ 'my-class':shouldAddClass }，那么元素会在shouldAddClass执行结果为真时，拥有my-class这个类名。                      
* 也可以在对象中指定多个class。
 ```html                      
 <div id="app">                   
    <!-- class为foo bar -->                 
    <div v-bind:class="classes"></div>                 
 </div>                     
 <script>                   
    new Vue({                  
       el: '#app',             
       data: {              
          shouldBeBar: true          
       },             
       computed: {             
          classes() {          
             return {       
                foo: true,     
                bar: this.shouldBar,    
                hello: false      
             }        
          }           
       }              
    });                  
 </script>    
 ```                 
 * 尽管我使用的是计算属性返回的对象，但这完全是可选的，                   
    这只是一个很好的方式来避免代码在有很多class时变得太长。                  
 * 也可以使用内联的方式设置这个对象。  
                  
##### 当你想要同时使用变量和条件判断来添加class时，也可以将数组和对象混合在一起使用，只需将对象放在数组中  
```javascript                
<div v-bind:class="[                      
 'my-class',                   
 classFromVariable,                     
 { 'conditional-class': hasClass }                     
]"></div>                        
```                        
     
                              
#### 内联样式绑定                              
虽然使用class来设置元素的样式通常会更好，但是内联样式同样有用，特别是使用变量动态设置样式的时候。                           
下面这个例子会渲染出12种不同的颜色，形成一个颜色样板： 
```html
<div id="app">                      
 <div v-for="n in 12" class="color" :style="{ backgroundColor: getColor(n)}">                    
 </div>                     
</div>                        
<script>                      
 new Vue({                     
    el: '#app',                
    methods: {                 
       getColor(n) {              
          return `hsl(${ (n-1) * 30 }, 100%, 75%)`;          
       }              
    }                 
 });                     
</script>       
```      
Vue会自动为你添加浏览器前缀：如果设置的某个样式需要浏览器兼容性前缀，Vue会自动把它加上。                      
                              
##### 为内联样式设置一个对象                         
```javascript
<div v-bind:style="{ fontWeight: 'bold', color: 'red' }"></div>
```
Vue会自动将该对象的属性由驼峰命名转为它们对应的CSS属性，这意味着不用再操心如何转义属性名中的短横杠了。                        
                              
##### 数组语法                          
可以使用一个数组来指定多个样式对象：                        
```javascript
<div :style="[baseStyle, moreStyles]">                      
   ...                     
</div>     
```                   
两个对象中的样式都会应用到元素上                       
如果有相同的样式名，那么moreStyles中的样式会覆盖baseStyle中的同名样式。                        
                              
##### 多重值                           
还可以使用数组提供多个值，来设置浏览器最终支持的值：                      
```javascript
<div :style="{ display: ['-webkit-box', '-ms-flexbox-', 'flex']}"></div>
```
如果浏览器支持，结果将会是display:flex，否则会尝试-ms-flexbox，再是-webkit-box。  
                                    
#### 用vue-loader实现Scoped CSS                               
* 当结合vue-loader使用组件时，可以使用scoped CSS来添加样式，并且只在该CSS所在的组件中有效。                            
除了`<template>`和`<script>`标签，也可以在该文件中使用`<style>`标签
   * 它将会在之后被输出到页面上
   * 或者还可以设置webpack将样式提取到一个外部的CSS文件中                             
      想要为前面的例子添加样式，来让数字变为粗体： 
      ```html                         
      <template>                          
         <p>当前数字是<span class="number"> {{ number }}</span></p>                      
      </template>                         
      <script>                         
         export default {                       
            props: {                   
               number: {                  
                  type: Number,              
                  required: true             
               }                 
            }                    
         }; 
      </script>                     
      <style>                          
         .number {                        
            font-weight: bold;                     
         }                       
      </style>                         
      ```                 
* Vue有一种方式可以修复这个问题：scoped CSS。                             
   与JavaScript不同，组件中的CSS不仅会影响自身，还会影响到页面上所有的HTML元素。  
   如果我们在style标签上添加了scoped特性，Vue就会自动处理关联的CSS与HTML，使编写的CSS只影响到该组件中的HTML。
   ```html                          
   <style scoped>
      .number {
         font-weight: bold;
      }                    
   </style>
   ``` 
   输出的HTML：    
  ```html                     
  <p data-v-e0e8ddca>当前数字是<span data-v-e0e8ddca class="number">10</span></p>                      
  <style>                       
     .number[data-v-e0e8ddca] {                   
        font-weight: bold;                  
     }                    
  </style> 
  ```                     
                                 
#### 用vue-loader实现CSS Modules                                 
   作为scoped CSS的替代方案，可以用vue-loader实现CSS Modules   
   ```html
   <template>                             
      <p>当前数字是<span :class="$style.number">{{ number }}</span></p>                           
   </template>                            
   <style module>                            
      .number {                           
         font-weight: bold;                        
      }                          
   </style>
   ```                            
   .number样式会被一个随机的样式名称所替换，可以通过$style.number来引用这个名称
                                    
### 预处理器
可以设置vue-loader来让预处理器处理CSS、JavaScript和HTML。    
想要使用SCSS，可以通过两个步骤来实现：                                 
* 首先通过npm安装sass-loader和node-sass                              
* 然后在style标签上添加lang="scss" 
    ```css                          
    <style lang="scss" scoped>                            
     $color: red;                           
     .number {                           
        font-weight: bold;                        
        color: $color;                      
     }                          
    </style>   
    ```                         
          

## &lt;a&gt; 标签
> [《从0到1：HTML+CSS快速上手》](https://weread.qq.com/web/reader/1053223071cad78210554c5kc81322c012c81e728d9d180)  
> [《CSS3网页设计从入门到精通（微课精编版）》](https://weread.qq.com/web/reader/80a32f207199a65080abd74kc81322c012c81e728d9d180)  
> [HTML 链接 · HTML · HTML系列教程 · W3school](https://www.w3school.com.cn/html/html_links.asp)  
> [HTML &lt;a&gt; 标签 · HTML/HTML5标签 · 参考手册 · W3school](https://www.w3school.com.cn/tags/tag_a.asp)  


### 超链接HTML
#### 超链接语法
`<a href="链接地址" target="打开方式">文本或图片</a>`
* a标签                        
在HTML中，我们可以使用a标签来实现超链接。      
我们通过使用 `<a>` 标签在 HTML 中创建链接。
* href属性                       
表示你想要跳转到的那个页面的路径（也就是地址），可以是相对路径，也可以是绝对路径。   
   * 将文本设置为超链接，这种叫作“文本超链接”   
   ```
   <a href="http://www.lvyestudy.com">绿叶学习网</a>
   ```                
   * 将图片设置为超链接，这种叫作“图片超链接”   
   ```
   <a href="http://www.lvyestudy.com"><img src="img/lvye.png" alt="绿叶学习网" /></a>
   ```                
* target属性                     
   默认情况下，超链接都是在当前浏览器<span class="s3">窗口</span>打开新页面的。                   
   在HTML中，我们可以使用target属性来定义超链接打开<span class="s3">窗口</span>的方式。                   
   a标签的target属性取值有4种：    
   <table>
      <tr><td>_self</td><td>在原来<span class="s3">窗口</span>打开链接（默认值）</td></tr>
      <tr><td>_blank</td><td>在新<span class="s3">窗口</span>打开链接</td></tr>
      <tr><td>_parent</td><td>在父<span class="s3">窗口</span>打开链接</td></tr>
      <tr><td>_top</td><td>在顶层<span class="s3">窗口</span>打开超链接</td></tr>
   </table>                 
        
#### 超链接有两种                      
1. 外部链接                          
   外部链接指向的是“外部网站的页面”                      
   `<a href="http://www.lvyestudy.com">绿叶学习网</a>`
2. 内部链接                          
   内部链接指向的是“自身网站的页面”                      
   `<a href="page2.html">跳转到页面2</a>`
   * 锚点链接                       
   它的链接地址（也就是href）指向的是当前页面的某个部分。                   
   ```html
   <a href="#article">推荐文章</a>                     
   <div id="article">                     
   ...                     
   </div> 
   ```                    
      * 想要实现锚点链接，需要定义以下2个参数：                   
      · 目标元素的id                     
      · a标签的href属性指向该id     
      
      
### 超链接样式
#### 在所有浏览器中，链接的默认外观是：                                       
* 未被访问的链接带有下划线而且是蓝色的   
<span style="color:rgb(0, 0, 238);text-decoration: underline;">我是超链接</span>                          
* 已被访问的链接带有下划线而且是紫色的   
<span style="color:rgb(85, 26, 139); text-decoration: underline;">我是超链接</span>                                   
* 活动链接带有下划线而且是红色的      
<span style="color:red; text-decoration: underline;">我是超链接</span>   
鼠标单击时：字体为红色，带有下划线。
鼠标单击时，指的是单击超链接的那一瞬间。也就是说，字体变为红色也就是一瞬间的事情。             
* 当鼠标指针移过链接对象时显示为手形，                                      
                                        
#### 设计超链接的基本样式                                        
   * 使用CSS3的**动态伪类选择器**定义超链接的4种状态样式。
      <table>
       <tr>
         <td>a:link</td>
         <td>定义超链接的默认样式</td>
       </tr>
       <tr>
         <td>a:visited</td>
         <td>定义超链接被访问后的样式</td>
       </tr>
       <tr>
         <td>a:hover</td>
         <td>定义鼠标指针移过超链接时的样式。</td>
       </tr>
       <tr>
         <td>a:active</td>
         <td>定义超链接被激活时的样式</td>
       </tr>
      </table>
      * :hover伪类
      可以定义任何一个元素在鼠标经过时的样式。注意，是任何元素。
      元素:hover{…}
      ```css
      div:hover { background-color: hotpink; }
      img:hover { border: 2px solid red; }
      ```
   * 超链接4种状态样式的排列顺序是固定的，一般不能随意调换。
   "love hate"
      ```   
      a.al:hover { color: #00FF00; }                                    
      a.al:active { color: #FFFF00; }                                   
      a.al:link { color: #FF0000; }                                   
      a.al:visited { color: #0000FF; }
      ```                            
      通过指定类型选择器，限定上面4个样式仅作用于包含al类的超链接中。  
      当鼠标经过超链接时，会先执行第1行声明，                                    
      但是紧接着第3行的声明会覆盖掉第1行和第2行声明的样式，所以就无法看到鼠标经过和被激活时的效果。                                    
   * 用户可以根据需要仅定义部分状态样式。                                      
      * 若要把未访问的和已经访问的链接定义成相同的样式  
      ``` 
      a.al:link { color: #FF0000; }                                 
      a.al:hover { color: #00FF00; }                                  
      a.al:active { color: #FFFF00; }     
      ```                            
      * 如果仅希望超链接显示两种状态样式   
      ```css                    
      a { color: #FF0000; }                                 
      a:hover { color: #00FF00; }    
      ```                             
      其中a标签选择器定义a元素的默认显示样式                                  
      然后定义鼠标经过时的样式                                  
      * 但是如果页面中包含锚记对象，将会影响锚记的样式。如果定义如下的样式，则仅影响超链接未访问时的样式和鼠标经过时的样式。                                    
      ```css
      a:link { color: #FF0000; }                                  
      a:hover { color: #00FF00; }                                 
      ```
   * 为什么我的浏览器中的超链接是紫色的呢？用color属性重新定义也无效，这是怎么回事？	
   如果某一个地址的超链接之前被单击过，浏览器就会记下你的访问记录。那么下次你再用这个已经访问过的地址作为超链接地址时，它就是紫色的了。小伙伴们换一个地址就可以了。
     

#### 定义下画线样式                                       
   * 使用CSS3的text-decoration属性进行清除                                      
      ```css
      a { text-decoration: none; }
      ```
   * 从用户体验的角度考虑，在取消默认的下画线之后，应确保浏览者可以识别所有超链接   
    如加粗显示、变色、缩放、高亮背景等。                                    
    也可以设计当鼠标经过时增加下画线，因为下画线具有很好的提示作用。  
      ```css
      a:hover { text-decoration: underline; }
      ```
   * 下画线样式不仅仅是一条实线，可以根据需要自定义设计。主要设计思路如下：  
      * 借助`<a>`标签的底边框线来实现。                                    
         * 当鼠标经过超链接文本时，显示为下画虚线、字体加粗、色彩高亮的效果  
            ```css
            a {                               
             text-decoration: none;                              
             color: #999;                              
            }                               
            a:hover {                               
             border-bottom: dashed 1px red;                              
             color: #000;                              
             font-weight: bold;                              
             zoom: 1;                              
            }               
            ```                
         * 定义超链接始终显示为下画线效果，并通过颜色变化来提示鼠标经过时的状态变化  
            ```css
            a {                               
             text-decoration: none;                              
             border-bottom: dashed 1px red;                              
             color: #666;                              
             zoom: 1;                              
            }                               
            a:hover {                               
             color: #000;                              
             border-bottom: dashed 1px #000;                             
            }         
            ```                      
      * 利用背景图像来实现，背景图像可以设计出更多精巧的下画线样式。      
         * 使用Photoshop设计一个虚线（images/dashed.psd），设计图像高度为1px，宽度为4px、6px或8px。具体宽度可根据虚线的疏密确定。     
         * 在Photoshop中，选择颜色以跳格方式进行填充，最后保存为GIF格式图像。  
         * 定义背景图像，定位到超链接元素的底部，并沿x轴水平平铺   
            ```css
            a {                                 
              text-decoration: none;                                
              color: #666;                                
            }                                 
            a:hover {                                 
              color: #000;                                
              background: url(images/dashed1.gif) left bottom repeat-x;                               
            }       
            ```                          
                                        
#### 定义特效样式                                        
为超链接文本设计立体视觉效果，主要是借助边框颜色的深浅错落，模拟一种凸凹变化的立体效果。   
 * 设置右边框和底边框同色，同时设置顶边框和左边框同色，利用明暗色彩的搭配来设计立体效果。  
 * 设置超链接文本的背景色为深色效果，营造凸起效果，当鼠标移过时，再定义浅色背景来营造凹下效果。                                    
 * 为网页设计浅色背景，再定义字体颜色来烘托立体样式。  

```css  
 a {                                   
   text-decoration: none;                                  
   border: solid 1px;                                  
   padding: 0.4em 0.8em;                                 
   color: #444;                                  
   background: #f99;                                 
   border-color: #fff #aaab9c #aaab9c #fff;                                  
   zoom: 1;  /* 解决IE浏览器无法显示问题 */                                 
 }                                   
 a:hover {                                   
   color: #800000;                                 
   background: transparent;                                  
   border-color: #aaab9c #fff #fff #aaab9c;                                  
 }                                   
```

#### 定义光标样式                                        
  * 在默认状态下，鼠标指针经过超链接时显示为手形。                
  * cursor属性定义鼠标移过对象时的指针样式，取值说明如下：    
      <table>
          <tr>
              <td>auto</td>
              <td>基于上下文决定应该显示什么光标</td>
          </tr>
          <tr>
              <td>crosshair</td>
              <td>十字线光标（+）</td>
          </tr>
          <tr>
              <td>default</td>
              <td>基于平台的默认光标。通常渲染为一个箭头。</td>
          </tr>
          <tr>
              <td>pointer </td>
              <td> 指针光标，表示一个超链接。 </td>
          </tr>
          <tr>
              <td>move </td>
              <td> 十字箭头光标，用于标示对象可被移动。 </td>
          </tr>
              <td>e-resize、ne-resize、nw-resize、n-resize、se-resize、sw-resize、s-resize、w-resize</td>
              <td> 表示正在移动某个边，如se-resize光标用来表示框的移动开始于东南角 </td>
          </tr>
          <tr>
              <td>text </td>
              <td> 表示可以选择文本。通常渲染为I形光标 </td>
          </tr>
          <tr>
              <td>wait </td>
              <td> 表示程序正忙，需要用户等待，通常渲染为手表或沙漏 </td>
          </tr>
          <tr>
              <td>help </td>
              <td> 光标下的对象包含帮助内容，通常渲染 为一个问号或一个气球 </td>
          </tr>
          <tr>
              <td>
                  &lt;uri&gt;URL
              </td>
              <td> 自定义光标类型的图标路径 </td>
          </tr>
      </table>
  * 使用自定义图像作为光标类型                                     
      * IE和Opera只支持*.cur等特定的图片格式                                    
      * Firefox、Chrome和Safari既支持特定图片类型，也支持常见的\*.jpg、\*.gif、\*.jpg等图片格式。                                    
    cursor属性值可以是一个序列，当用户端无法处理第1个图标时，它会尝试处理第2个、第3个等，如果用户端无法处理任何定义的光标，则必须使用列表最后的通用光标。  
    例如，下面样式中就定义了3个自定义动画光标文件，最后定义了1个通用光标类型。    
      ```css
      a:hover { cursor: url('images/1.ani'), url('images/1.cur'), url('images/1.gif'), pointer; }
      ```

## window.location 浏览器定位和导航
> [《JavaScript权威指南（第6版）》](https://weread.qq.com/web/reader/0513214059343c051f11bc8kc81322c012c81e728d9d180)


### 如何使用location属性来获取当前显示文档的URL 
* Location对象              
Location对象表示该<span class="s3">窗口</span>中当前显示的文档的URL，并定义了方法来使<span class="s3">窗口</span>载入新的文档。
  * Window对象的location属性引用的是Location对象，Document对象的location属性也引用到Location对象：
  ```javascript 
  window.location === document.location // 总是返回true 
  ```          
                 
  * Document对象也有一个URL属性是文档首次载入后保存该文档的URL的静态字符串。           
  如果定位到文档中的**片段标识符**（如#table-of-contents），Location对象会做相应的更新，而document.URL属性却不会改变。            
              
* 解析URL             
#### <span class="s9">href属性</span>          
   是一个字符串，后者包含URL的完整文本。       
#### *toString()*方法          
   返回<span class="s9">href属性</span>的值        
   因此在会隐式调用*toString()*的情况下，可以使用location代替location.href       
#### <span class="s9">URL分解属性</span>    
    
分别表示URL的各个部分。        
同时被Link对象（通过HTML文档中的`<a>`和`<area>`元素创建）支持。       
参阅本书第四部分的Location和Link项获取详细信息。 
##### host        
##### hostname       
##### port        
##### pathname     
##### <span class="s9">hash</span>  
<span class="s9">hash属性</span>返回URL中的“**片段标识符**”部分
##### search  
search属性也类似，它返回的是问号之后的URL，这部分通常是某种类型的查询字符串。        
  * 一般来说，这部分内容是用来参数化URL并在其中嵌入参数的。虽然这些参数通常用于运行在服务器上的脚本，但在启用JavaScript的页面中当然也可以使用它们。         
  * 例14-2展示了一个通用函数urlArgs（）的定义，可以用这个函数将参数从URL的search属性中提取出来。       
  该例子用到了decodeURIComponent（），后者是在客户端JavaScript定义的全局函数。（参见本书第三部分中的Global获取详细内容。） 
   ```javascript      
   /*    
    * 这个函数用来解析来自URL的查询串的name=value参数对     
    * 它将name = value对存储在一个对象的属性中，并返回该对象      
    * 这样来使用它      
    *    
    * var args = urlArgs(); // 从URL中解析参数     
    * var q = args.q || ""; // 如果参数定义了的话就使用参数；否则使用一个默认值     
    * var n = args.n ? parseInt(ars.n) : 10;    
    */      
   function urlArgs() {    
      var args = {}; // 定义一个空对象  
      var query = location.search.substring(1); // 查找到查询串，并去掉'?'  
      var pairs = query.split("&");  // 根据"&"符号查询字符串分隔开  
      for( var i = 0; i < pairs.length; i++) {  // 对于每个片段   
         var pos = pairs[i].indexOf('='); // 查找"name=value"
         if(pos == -1) continue; // 如果没有找到的话，就跳过
         var name = pairs[i].substring(0, pos); // 提取name
         var value = pairs[i].substring(pos+1); // 提取value
         value = decodeURIComponent(value); // 对value进行解码
         args[name] = value; // 存储为属性
      }  
      return args; // 返回解析后的参数   
   }     
   ```      
       
### 如何使用location属性载入新的文档                
#### *assign()*方法               
可以使<span class="s3">窗口</span>载入并显示你指定的URL中的文档。           
#### *replace()*方法             
也类似，但它在载入新文档之前会从浏览历史中把当前文档删除。          
* 如果脚本无条件地载入一个新文档，*replace()*方法可能是比*assgin()*方法更好的          
否则，“后退”按钮会把浏览器带回到原始文档，而相同的脚本则会再次载入新文档。          
* 如果检测到用户的浏览器不支持某些特性来显示功能齐全的版本，可以用location.*repla)*来载入静态的HTML版本。    
```javascript        
// 如果浏览器支持XMLHttpRequest对象          
// 则将其重定向到一个不需要Ajax的静态页面            
if(!XMLHttpRequest) location.replace("staticpage.html");          
// 注意，在这个例子中传入*replace()*的是一个相对URL。         
// 相对URL是相对于当前页面所在的目录来解析的，就像将它们用于一个超链接中。
```         
#### *reload()*方法               
  可以让浏览器重新载入当前文档。            
#### 直接把新的URL赋给location属性
使浏览器跳转到新页面的一种更传统的方法            
* 绝对URL
```javascript
location = "http://www.oreilly.com"; // 在此网站购买书！   
```      
* 把相对URL赋给location，它们会相对当前URL进行解析    
```javascript        
location = "page2.html"; // 载入下一个页面    
```  
* 纯粹的**片段标识符**是相对URL的一种类型，它不会让浏览器载入新文档，动到文档的某个位置。        
`#top`标识符是个特殊的例子：如果文档中没有元素的ID是“top”，它会让浏览器跳。 
```javascript
location = "#top"; // 跳转到文档的顶部    
```        
#### Location对象的<span class="s9">URL分解属性</span>是可写的，对它们重新赋值会改变URL的位置，并且导致浏览器载入一个新的文档             
```javascript          
location.search = "?page=" + (pagenum+1); // 载入下一个页面  
``` 
如果改变的是<span class="s9">hash属性</span>，则在当前文档中进行跳转       
              
## window.open 多<span class="s3">窗口</span>和<span class="s4">窗体</span>  
> [《JavaScript权威指南（第6版）》](https://weread.qq.com/web/reader/0513214059343c051f11bc8kc81322c012c81e728d9d180)

    
* 标签页       
   * 一个Web浏览器<span class="s3">窗口</span>可能在桌面上包含多个标签页。               
   * 每一个标签页都是独立的**“浏览上下文”（browsingcontext）**，               
   每一个**上下文**都有独立的Window对象，而且相互之间互不干扰。           
   每个标签页中运行的脚本通常并不知道其他标签页的存在，          
   更不用说和其他标签页的Window对象进行交互操作或者操作其文档内容了。            
   * 如果Web浏览器不支持多标签页，或者把标签页关掉了，可能在某一时刻桌面上会有很多打开的Web浏览器<span class="s3">窗口</span>。           
   而使用标签页，每个桌面<span class="s3">窗口</span>中的Window对象都是独立的，也就是说彼此就是完全独立的，和其他桌面<span class="s3">窗口</span>没有任何联系。  


* `<iframe>`             
   * HTML文档经常使用`<iframe>`来嵌套多个文档。             
   由`<iframe>`所创建的嵌套**浏览上下文**是用它自己的Window对象所表示的。            
   * 废弃的`<frameset>`和`<frame>`元素同样创建了一个嵌套的**浏览上下文**，每一个<frame>都由一个独立的Window对象表示。           
   * 对于客户端JavaScript来说，<span class="s3">窗口</span>、标签页、iframe和框架都是**浏览上下文**；            
   对于JavaScript来说，它们都是Window对象。           
   * 和相互独立的标签页不同，嵌套的**浏览上下文**之间并不是相互独立的。           
      在一个<span class="s4">窗体</span>中运行的JavaScript程序总是可以看到它的祖先和子孙<span class="s4">窗体</span>，尽管脚本查看这些<span class="s4">窗体</span>中的文档受到**同源策略**的限制。        
      14.8.2节会讲到嵌套的<span class="s4">窗体</span>。        
      
      
* 但是<span class="s3">窗口</span>并不总是和其他<span class="s3">窗口</span>完全没关系。              
   一个<span class="s3">窗口</span>或标签页中的脚本可以打开新的<span class="s3">窗口</span>或标签页，当一个脚本这样做时，这样多个<span class="s3">窗口</span>或<span class="s3">窗口</span>与另一个<span class="s3">窗口</span>的文档之间就可以互操作（可以参照13.6.2节中讲解的**同源策略**约束）。           
   14.8.1节介绍关于<span class="s3">窗口</span>打开和关闭的更多内容。       
        
* 因为Window是客户端JavaScript的<span class="s5">全局对象</span>，每个<span class="s3">窗口</span>或<span class="s4">窗体</span>都包含独立的JavaScript<span class="s2">执行上下文</span>。    
   不过，在一个<span class="s3">窗口</span>中的JavaScript代码，如果有**同源策略**的限制，则可以使用另外一个<span class="s3">窗口</span>中定义的对象、属性和方法。           
   与此相关的细节会在14.8.3节中详细讨论。           
   当由于**同源策略**的限制导致<span class="s3">窗口</span>之间无法直接交互时，HTML5提供一个基于事件的消息传输API，可以用于间接的通信。这在22.3节中会有详细讨论。          
               
               
如何打开和关闭浏览器<span class="s3">窗口</span>                  
### 打开<span class="s3">窗口</span>              
使用Window对象的*open（）*方法可以打开一个新的浏览器<span class="s3">窗口</span>（或标签页，这通常和浏览器的配置选项有关）。            
Window.*open（）*载入指定的URL到新的或已存在的<span class="s3">窗口</span>中，并返回代表那个<span class="s3">窗口</span>的Window对象。           
* #### *open()*有4个可选的参数：     
   1. 要在新<span class="s3">窗口</span>中显示的文档的URL。      
      如果这个参数省略了（也可以是空字符串），那么会使用空页面的URL about:blank。      
   2. 新打开的<span class="s3">窗口</span>的名字    
      * <span class="s3">窗口</span>的名字
         * 如果指定的是一个已经存在的<span class="s3">窗口</span>的名字（并且脚本允许跳转到那个<span class="s3">窗口</span>），会直接使用已存在的<span class="s3">窗口</span>。     
         * 否则，会打开新的<span class="s3">窗口</span>，并将这个指定的名字赋值给它。     
         * 如果省略此参数，会使用指定的名字“<span class="s6">_blank</span>”打开一个新的、未命名的<span class="s3">窗口</span>。    
            
      * 需要注意的是，脚本是无法通过简单地猜测<span class="s3">窗口</span>的名字来操控这个<span class="s3">窗口</span>中的Web应用的，只有设置了“允许导航”（allowed to navigate）（HTML5规范中的术语）的页面才可以这样。     
      宽泛地讲，当且仅当<span class="s3">窗口</span>包含的文档来自相同的源或者是这个脚本打开了那个<span class="s3">窗口</span>（或者递归地打开了<span class="s3">窗口</span>中打开的<span class="s3">窗口</span>），脚本才可以只通过名字来指定存在的<span class="s3">窗口</span>。    
      * 如果其中一个<span class="s3">窗口</span>是内嵌在另一个<span class="s3">窗口</span>里的<span class="s4">窗体</span>，那么在它们的脚本之间就可以相互导航。     
      这种情况下，可以使用保留的名字“<span class="s6">_top</span>”（顶级祖先<span class="s3">窗口</span>）和“<span class="s6">_parent</span>”（直接父级<span class="s3">窗口</span>）来获取彼此的**浏览上下文**。    
            
      * <span class="s3">窗口</span>的名字是非常重要的，      
         * 因为它允许*open（）*方法引用已存在的<span class="s3">窗口</span>，  
         * 并同时可以作为`<a>`和`<form>`元素上HTML target属性的值，用来表示引用的文档（或表单提交结果）应该显示在命名的<span class="s3">窗口</span>中。   
            这个target属性的值可以设置为“<span class="s6">_blank</span>”、“<span class="s6">_parent</span>”或“<span class="s6">_top</span>”，从而使引用的文档显示在新的空白<span class="s3">窗口</span>、父<span class="s3">窗口</span>/<span class="s4">窗体</span>或顶层<span class="s3">窗口</span>中。
         * Window对象如果有name属性，就用它保存名字。   
            该属性是可写的，并且脚本可以随意设置它。  
            * 如果传递给window.*open（）*一个除“<span class="s6">_blank</span>”之外的名字，通过该调用创建的<span class="s3">窗口</span>将以该名字作为name属性的初始值。  
            * 如果`<iframe>`元素有name属性，表示该iframe的Window对象会用它作为name属性的初始值。  
            
   3. 一个以逗号分隔的列表，包含大小和各种属性，用以表明新<span class="s3">窗口</span>是如何打开的。       
      * 如果省略这个参数
         * 那么新<span class="s3">窗口</span>就会用一个默认的大小，而且带有一整组标准的UI组件，即菜单栏、状态栏、工具栏等。      
         * 在标签式浏览器中，会创建一个新的标签。     
            
      * 如果指定这个参数，就可以指定<span class="s3">窗口</span>的尺寸，以及它包含的一组属性。（显式指定<span class="s3">窗口</span>尺寸更像是创建新<span class="s3">窗口</span>，而不是新标签。）    
         例如，要打开允许改变大小的浏览器<span class="s3">窗口</span>，并且包含状态栏、工具栏和地址栏，就可以这样写：  
         ```javascript 
         var w = window.open("smallwin.html", "smallwin", "width=400,height=350,status=yes,resizable=yes"); 
         ```
            
      * 第三个参数是非标准的，HTML5规范也主张浏览器应该忽略它。      
         参见第四部分中的Window.*open（）*查看在此参数中可以指定什么内容。  
         注意，当指定第三个参数时，所有没有显式指定的功能都会忽略。   
         出于各种安全原因，浏览器包含对可能指定的功能的限制。   
         例如，通常不允许指定一个太小的或者位于屏幕之外的<span class="s3">窗口</span>，并且一些浏览器不允许创建一个没有状态栏的<span class="s3">窗口</span>。 
            
   4. 只在第二个参数命名的是一个存在的<span class="s3">窗口</span>时才有用。       
      它是一个布尔值，
      * true: 声明了由第一个参数指定的URL是应用替换掉<span class="s3">窗口</span>浏览历史的当前条目    
      * false: 还是应该在<span class="s3">窗口</span>浏览历史中创建一个新的条目
      后者是默认的设置。  
         
* #### *open（）*的返回值           
   是代表命名或新创建的<span class="s3">窗口</span>的Window对象。        
   可以在自己的JavaScript代码中使用这个Window对象来引用新创建的<span class="s3">窗口</span>，就像使用隐式的Window对象window来引用运行代码的<span class="s3">窗口</span>一样：         
   ```javascript
   var w = window.open(); // 打开一个新的空白<span class="s3">窗口</span>         
   w.alert("About to visit http://example.com"); // 调用alert()方法         
   w.location = "http://example.com"; // 设置它的location属性        
   ```
            
   * 在由window.*open（）*方法创建的<span class="s3">窗口</span>中，opener属性引用的是打开它的脚本的Window对象。        
   * 在其他<span class="s3">窗口</span>中，opener为null： 
      ```javascript       
      w.opener !== null; // true，对于由w创建的任意<span class="s3">窗口</span>    
      w.open().opener === w; // true， 对于任意<span class="s3">窗口</span>w    
      ```  
            
* Window.*open（）*是广告商用来在你浏览网页时采用的“页面之前弹出”或“页面之后弹出”<span class="s3">窗口</span>的一种方法。            
   由于对于这种烦人的弹出<span class="s3">窗口</span>的滥用，因此大部分浏览器都增加了弹出<span class="s3">窗口</span>过滤系统。       
   通常，*open（）*方法只有当用户手动单击按钮或者链接的时候才会调用。        
   JavaScript代码尝试在浏览器初始载入（或卸载）时开启一个弹出<span class="s3">窗口</span>时，通常会失败。       
   将上面的代码粘贴到浏览器的JavaScript控制台里进行测试，可能会由于同样的原因而失败。        
               
### 关闭<span class="s3">窗口</span>              
   * 方法*close（）*将关闭一个<span class="s3">窗口</span>。           
   如果已经创建了Window对象w，可以使用如下的代码将它关掉：  
   ```javascript         
      w.close();        
   ```
   运行在那个<span class="s3">窗口</span>中的JavaScript代码则可以使用下面的代码关闭：  
   ```javascript         
   window.close();        
   ``` 
   要显式地使用标识符window，这样可以避免混淆Window对象的*close（）*方法和Document对象的*close（）*方法——如果正在从事件处理程序调用*close（）*，这很重要。        
   * 大多数浏览器只允许自动关闭由自己的JavaScript代码创建的<span class="s3">窗口</span>。          
   如果要关闭其他<span class="s3">窗口</span>，可以用一个对话框提示用户，要求他对关闭<span class="s3">窗口</span>的请求进行确认（或取消）。          
      在表示<span class="s4">窗体</span>而不是顶级<span class="s3">窗口</span>或标签页上的Window对象上执行*close（）*方法不会有任何效果，它不能关闭一个<span class="s4">窗体</span>（反之可以从它包含的文档中删除iframe）。         
      即使一个<span class="s3">窗口</span>关闭了，代表它的Window对象仍然存在。         
      已关闭的<span class="s3">窗口</span>会有个值为true的closed属性，它的document会是null，它的方法通常也不会再工作。        
               
### <span class="s4">窗体</span>之间的关系              
   * Window对象的方法*open（）*返回代表新创建的<span class="s3">窗口</span>的Window对象。           
      而且这个新<span class="s3">窗口</span>具有opener属性，该属性可以打开它的原始<span class="s3">窗口</span>。       
      这样，两个<span class="s3">窗口</span>就可以相互引用，彼此都可以读取对方的属性或是调用对方的方法。        
   * <span class="s4">窗体</span>也是这样的。          
   * <span class="s3">窗口</span>或<span class="s4">窗体</span>中运行的代码都可以通过下面介绍的属性引用到自己的<span class="s3">窗口</span>或<span class="s4">窗体</span>，以及嵌套的子<span class="s4">窗体</span>。          
               
      1. 任何<span class="s3">窗口</span>或<span class="s4">窗体</span>中的JavaScript代码都可以将自己的<span class="s3">窗口</span>和<span class="s4">窗体</span>引用为window或<span class="s9">self</span>。            
      2. <span class="s9">parent</span>和<span class="s9">top</span>属性允许脚本引用它的<span class="s4">窗体</span>的祖先。          
         * <span class="s4">窗体</span>可以用<span class="s9">parent</span>属性引用包含它的<span class="s3">窗口</span>或<span class="s4">窗体</span>的Window对象： 
         ```javascript          
         parent.history.back();        
         ```
         * 如果一个<span class="s3">窗口</span>是顶级<span class="s3">窗口</span>或标签，而不是<span class="s4">窗体</span>，那么其<span class="s9">parent</span>属性引用的就是这个<span class="s3">窗口</span>本身：          
         ```javascript
         parent == self; // 只有顶级窗口才会返回true 
         ```        
   
         * 如果一个<span class="s4">窗体</span>包含在另一个<span class="s4">窗体</span>中，而后者又包含在顶级<span class="s3">窗口</span>中，那么该<span class="s4">窗体</span>就可以使用<span class="s9">parent</span>.<span class="s9">parent</span>来引用顶级<span class="s3">窗口</span>。            
         * <span class="s9">top</span>属性是一个通用的快捷方式，无论一个<span class="s4">窗体</span>被嵌套了几层，它的<span class="s9">top</span>属性引用的都是指向包含它的顶级<span class="s3">窗口</span>。        
         * 如果一个Window对象代表的是一个顶级<span class="s3">窗口</span>，那么它的<span class="s9">top</span>属性引用的就是<span class="s3">窗口</span>本身。         
         * 对于那些顶级<span class="s3">窗口</span>的直接子<span class="s4">窗体</span>，<span class="s9">top</span>属性就等价于<span class="s9">parent</span>属性。         
      3. 有不止一种方法可以引用<span class="s3">窗口</span>或<span class="s4">窗体</span>的子孙<span class="s4">窗体</span>。        
         * 可以用获取其他元素的方法来获取一个表示`<iframe>`的元素对象。        
        <span class="s4">窗体</span>是通过`<iframe>`元素创建的。               
         假定文档里有`<iframeid="f1">`。那么，表示该iframe的元素对象就是：   
         ```javascript   
         var iframeElement = document.getElementById("f1");    
         ```
         `<iframe>`元素有contentWindow属性，引用该<span class="s4">窗体</span>的Window对象，所以此<span class="s4">窗体</span>的Window对象就是：          
         ```javascript
         var childFrame = document.getElementById("f1").contentWindow;      
         ``` 
         * 尽管如此，通常不需要使用getElementById（）方法和contentWindow属性来获取<span class="s3">窗口</span>中子<span class="s4">窗体</span>的引用。每个Window对象都有一个frames属性，它引用自身包含的<span class="s3">窗口</span>或<span class="s4">窗体</span>的子<span class="s4">窗体</span>。        
            * frames属性引用的是**类数组对象**，并可以通过数字或<span class="s4">窗体</span>名进行索引。     
         要引用<span class="s3">窗口</span>的第一个子<span class="s4">窗体</span>，可以用frames[0]。    
         要引用第二个子<span class="s4">窗体</span>的第三个子<span class="s4">窗体</span>，可以用frames[1].frames[2]。     
         <span class="s4">窗体</span>里运行的代码可以用<span class="s9">parent</span>.frames[1]引用兄弟<span class="s4">窗体</span>。     
         注意frames[]数组里的元素是Window对象，而不是`<iframe>`元素。     
            * 如果指定`<iframe>`元素的name或id属性，那么除了用数字进行索引之外，还可以用名字来进行索引。       
         例如，名字为“f1”的帧应该用frames["f1"]或frames.f1。  
                        
         * 从表示<span class="s4">窗体</span>的Window对象来获取该<span class="s4">窗体</span>的``<iframe>``元素——用Window对象的frameElement属性。          
      表示顶级<span class="s3">窗口</span>的Window对象的frameElement属性为null，         
      <span class="s4">窗体</span>中的Window对象的frameElement属性不是null：     
      ```javascript   
      var elt = document.getElementById("f1");        
      var win = elt.contentWindow;        
      win.frameElement === elt   // 对于帧来说永远是true         
      window.frameElement === null // 对于顶级<span class="s3">窗口</span>来说永远是true   
      ```    

  
               
   * 刚刚在14.7节中讲到，`<iframe>`以及其他元素的name和ID都可以自动通过Window对象的属性来应用，而`<iframe>`元素和其他的元素有所不同：            
      * 对于<span class="s4">窗体</span>来说，通过Window对象的属性引用的`<iframe>`是指<span class="s4">窗体</span>中的Window对象，而不是元素对象。         
         * 也就是说，可以通过<span class="s4">窗体</span>的名字“f1”来代替frames.f1。     
         实际上，HTML5规范指出frames属性是一个自引用（self-referential）的属性，就像window和<span class="s9">self</span>一样。    
         * 而这个Window对象看起来像一个由<span class="s4">窗体</span>组成的数组。    
            也就是说可以通过window[0]来获取第一个子<span class="s4">窗体</span>的引用，   
            可以通过window.length或length查询<span class="s4">窗体</span>的编号。 
         * 但是这里我们使用frames来代替window会比较清晰一些，尽管这种方法有些传统。      
            需要注意的是，当前的浏览器不会让frame==window，但在frame和window不相等的情况下，可以通过子<span class="s4">窗体</span>的索引或名字来获取其他对象的引用。  
               
      * 可以使用`<iframe>`的元素的name或id属性作为JavaScript代码中的引用标识。           
      但如果使用name属性的话，所指定的name同样也会成为代表这个<span class="s4">窗体</span>的Window对象的name属性。         
      以这种方式给出的名字可以用做一个链接的target属性，而且它可以用做window.*open（）*的第二个参数。        
               
               
### 如何编写可以在多个<span class="s3">窗口</span>和嵌套<span class="s4">窗体</span>中工作的JavaScript代码                
交互<span class="s3">窗口</span>中的JavaScript              
   * 每个<span class="s3">窗口</span>和<span class="s4">窗体</span>都是它自身的JavaScript<span class="s2">执行上下文</span>，以Window作为<span class="s5">全局对象</span>。           
   * 但是如果一个<span class="s3">窗口</span>或<span class="s4">窗体</span>中的代码可以应用到其他<span class="s3">窗口</span>或<span class="s4">窗体</span>（并且**同源策略**没有阻止它），那么一个<span class="s3">窗口</span>或<span class="s4">窗体</span>中的脚本就可以和其他<span class="s3">窗口</span>或<span class="s4">窗体</span>中的脚本进行交互。          
      * 设想一个Web页面里有两个`<iframe>`元素，分别叫“A”和“B”，并假设这些<span class="s4">窗体</span>所包含的文档来自于相同的一个服务器，并且包含交互脚本。         
         * <span class="s4">窗体</span>A里的脚本定义了一个变量i：   
            ```javascript  
            var i = 3;  
            ```
            这个变量只是<span class="s5">全局对象</span>的一个属性，也是Window对象的一个属性。 
            * <span class="s4">窗体</span>A中的代码可以用标识符i来引用变量，  
            * 或者用window对象显式地引用这个变量： 
               window.i
         * 由于<span class="s4">窗体</span>B中的脚本可以引用<span class="s4">窗体</span>A的Window对象，因此它也可以引用那个Window对象的属性：    
            ```javascript  
            parent.A.i = 4; // 改变<span class="s4">窗体</span>A中的变量i的值  
            ```
               
      * 如果<span class="s4">窗体</span>B中的脚本声明了一个（非嵌套的）函数f，这个函数在<span class="s4">窗体</span>B中是全局变量，并且<span class="s4">窗体</span>B中的代码可以用f（）调用f。  
         但是<span class="s4">窗体</span>A中的代码必须将f作为<span class="s4">窗体</span>B的Window对象的f属性来引用：         
         定义函数的关键字function可以声明一个变量，就像关键字var所做的那样。
         ```javascript      
         var f = parent.B.f;     
         ```
         现在<span class="s4">窗体</span>A中的代码就可以像<span class="s4">窗体</span>B中的代码那样调用函数f（）了。     
               
         当采用这种方式在<span class="s4">窗体</span>或<span class="s3">窗口</span>间共享函数时，牢记词法作用域的规则非常重要。    
         函数在定义它的作用域中执行，而不是在调用它的作用域中执行。 
         就上面那个例子来说，如果函数f引用了全局变量，那么将在<span class="s4">窗体</span>B的属性中查找这些变量，即使函数是由<span class="s4">窗体</span>A调用的。   
      * 要记住构造函数也是函数，所以当用构造函数和相关的原型对象定义一个类（见第9章）时，那个类只在一个单独的<span class="s3">窗口</span>中定义。         
         假设在例子9-6中的<span class="s3">窗口</span>包含<span class="s4">窗体</span>A和<span class="s4">窗体</span>B，并且包含Set类。     
         * 顶级<span class="s3">窗口</span>中的脚本可以创建新的Set对象，类似这样：
            ```javascript      
            var s = new Set();   
            ```
         * 相反，每个<span class="s4">窗体</span>中的代码必须显式地用父级<span class="s3">窗口</span>的属性来引用Set（）构造函数： 
            ```javascript     
            var s = new parent.Set();
            ```  
         * 另外，每个<span class="s4">窗体</span>中的代码还可以定义自己的变量来引用构造函数，这样就更方便了：
            ```javascript      
            var Set = top.Set(); 
            var s = new Set();   
            ```
         * 和用户定义的类不同，内置的类（比如String，Date和RegExp）都会在所有的<span class="s3">窗口</span>中自动预定义。      
         但是要注意，每个<span class="s3">窗口</span>都有构造函数的一个独立副本和构造函数对应原型对象的一个独立副本。   
         例如，每个<span class="s3">窗口</span>都有自己的String（）构造函数和String.prototype对象的副本。
         因此，如果编写一个操作JavaScript字符串的新方法，并且通过把它赋值给当前<span class="s3">窗口</span>中的String.prototype对象而使它成为String类的一个方法，那么该<span class="s3">窗口</span>中的所有字符串就都可以使用这个新方法。
         但是，别的<span class="s3">窗口</span>中定义的字符串不能使用这个新方法。
         * 事实上，每个Window都有自己的原型对象，这意味着instanceof操作符不能跨<span class="s3">窗口</span>工作。    
            例如，当用instanceof来比较<span class="s4">窗体</span>B的一个字符串和<span class="s4">窗体</span>A的String（）构造函数时，结果会为false。 
            7.10节介绍了决定跨<span class="s3">窗口</span>数组的类型时的相关困难。  
               
   * WindowProxy对象           
      我们已经讲过很多次，Window对象是客户端JavaScript的全局变量。但是从技术上来看，并不是这样的。         
      Web浏览器每次向<span class="s3">窗口</span>或<span class="s4">窗体</span>中载入新的内容，它都会开始一个新的JavaScript<span class="s2">执行上下文</span>，包含一个新创建的<span class="s5">全局对象</span>。         
      但是当多个<span class="s3">窗口</span>或<span class="s4">窗体</span>在使用时，有一个重要的概念，尽管<span class="s4">窗体</span>或<span class="s3">窗口</span>载入了新的文档，但是引用<span class="s4">窗体</span>或<span class="s3">窗口</span>的Window对象还仍然是一个有效的引用。         
      所以客户端JavaScript有两个重要的对象。         
      1. 客户端<span class="s5">全局对象</span>处于作用域链的顶级，并且是全局变量和函数所定义的地方。     
            事实上，<span class="s5">全局对象</span>会在<span class="s3">窗口</span>或<span class="s4">窗体</span>载入新内容时被替换。  
      2. 我们称为“Window对象”的对象实际上不是<span class="s5">全局对象</span>，而是<span class="s5">全局对象</span>的一个代理。      
            每当查询或设置Window对象的属性时，就会在<span class="s3">窗口</span>或<span class="s4">窗体</span>的当前<span class="s5">全局对象</span>上查询或设置相同的属性。   
            HTML5规范称这个代理对象为WindowProxy，但在本书中我们会继续使用名词Window对象。   
            由于它的代理行为，除了有更长的生命周期之外，代理对象表现得像真正的<span class="s5">全局对象</span>。   
         如果可以比较两个对象，那么区分它们会很困难。     
         但是事实上，没有办法可以引用到真正的客户端<span class="s5">全局对象</span>。    
         <span class="s5">全局对象</span>处于作用域链的顶端，但是window、<span class="s9">self</span>、<span class="s9">top</span>、<span class="s9">parent</span>以及<span class="s4">窗体</span>的属性全部返回代理对象。      
         window.*open（）*方法也返回代理对象。    
         甚至顶级函数里this关键字的值都是代理对象，而不是真正的<span class="s5">全局对象</span>      
         最后一点对于ES3和ES5规范稍有违背，但客户端JavaScript是需要支持这种多重<span class="s2">执行上下文</span>的。      


## HTML元素的ID和name作为Window对象的属性来使用（作为Window对象属性的文档元素）  
   * 如果在HTML文档中用id属性来为元素命名，并且如果Window对象没有此名字的属性，Window对象会赋予一个属性，它的名字是id属性的值，而它们的值指向表示文档元素的HTMLElement对象。
      * 在客户端JavaScript中，Window对象是以<span class="s5">全局对象</span>的形式存在于作用域链的最上层，这就意味着在HTML文档中使用的id属性会成为可以被脚本访问的全局变量。              
      如果文档包含一个`<button id="okay"/>`元素，可以通过全局变量okay来引用此元素。           
      * 有一个重要的警告：如果Window对象已经具有此名字的属性，这就不会发生。              
         * 比如，id是“history”、“location”或“navigator”的元素，就不会以全局变量的形式出现，因为这些ID已经占用了。          
         * 如果脚本中的变量声明出现在命名元素之前，那这个变量的存在就会阻止元素获取它的window属性。          
         * 而如果脚本中的变量声明出现在命名元素之后，那么变量的显式赋值会覆盖该属性的隐式值。          
         * 同样，如果HTML文档包含一个id为“x”的元素，并且还在代码中声明并赋值给全局变量x，那么显式声明的变量会隐藏隐式的元素变量。        
      * 通过document.getElementById（）方法，用HTML的id属性来查找文档元素。  
   见下面的例子：     
       ```javascript         
       var ui = ["input", "prompt", "heading"];  // 数组中存放要查找的元素id           
       ui.forEach(function(id) {   // 用每个id查找对应的元素           
          ui[id] = document.getElementById(id);  // 将其存放在一个属性中        
       });            
       ```
      运行完这段代码之后，ui.input、ui.prompt和ui.heading会引用文档元素。          
      脚本可以用全局变量input和heading来代替ui.input和ui.heading。            
      但记得14.5节里的Window对象有个方法的名字是prompt（），所以脚本中不能用全局变量prompt代替ui.prompt。          
                  
   * 元素ID作为全局变量的隐式应用是Web浏览器演化过程中遗留的怪癖。               
      它主要是出于与已有Web页面后向兼容性的考虑。          
      * 但这里并不推荐使用这种做法——浏览器厂商可以在任何时候为Window对象定义新属性，而这些新属性都会破坏使用了此属性名的隐式定义的代码。          
      * 反之，用document.getElementById（）来显式查找元素。如果给它一个更简单的名字，这种用法会变得更加简便。
          ```javascript             
             var $ = function(id) { return document.getElementById(id); };        
             ui.prompt = $("prompt");  
         ```       
      * 很多客户端类库都定义了$函数，类似上面一样来通过ID查找元素。           
      （我们会在第19章里看到jQuery的$函数作为通用的元素选择方法，基于ID、标签名、class属性或其他标准，返回一个或多个元素。）           
   * 假设ID并没有被Window对象使用的话，那么任何有id属性的HTML元素都会成为全局变量的值。 以下HTML元素如果有name属性的话，也会这样表现：         
    `<a>`  
    `<applet>`  
    `<area>`  
    `<embed>`  
    `<form>`  
    `<frame>`  
    `<frameset>`  
    `<iframe>`  
    `<img>`  
    `<object>`  
    
   * id元素在文档中必须是唯一的：两个元素不能有相同的id。但是，这对name属性无效。    
   如果上面的元素有多于一个有相同的name属性（或者一个元素有name属性，而另一个元素有相同值的id属性），具有该名称的隐式全局变量会引用一个**类数组对象**，这个**类数组对象**的元素是所有命名的元素。         
                  
   * 有name或id属性的`<iframe>`元素是个特殊的例子。          
   为它们隐式创建的变量不会引用表示元素自身的Element对象，        
   而是引用表示`<iframe>`元素创建的嵌套浏览器窗体的Window对象。         
                     


## 截取字符串方法：substring()、substr()和slice()
> [《JavaScript修炼之道》](https://weread.qq.com/web/reader/89c3201071d3be5089c30d8kc81322c012c81e728d9d180)  >

3个方法功能类似，都可以截取字符串，但它们的参数含义有所不同。                                               
### 1. substring(**startIndex \[,endIndex\]**)                         
   ```javascript
   var oStr = "Hello, can I help you?";   
   ```                                          
   * 用于提取并返回字符串索引值startIndex到endIndex-1之间的字符串。                                           
      substring()必须至少有一个参数为正数，否则无结果输出。                                        
      ```javascript
      alert(oStr.substring(6, 9)); // 提取第6~8之间的字符，输出：can    
      ```                                    
   * 参数为负数时会看成0。                                           
      ```javascript
      alert(oStr.substring(-4); // 将负数看成0，输出：Hello, can I help you?     
      ```                                    
      而且为负数的参数永远都只能作为第一个参数，且其值都会被看成0。                                      
      所以，substring(2,-3)等效于substring(0,2)，substring(-4)等效于substring(0)。                                     
   * 如果第一个参数为正数，第二个参数为负数，则两个参数会对调位置。                                            
      ```javascript
      alert(oStr.substring(2, -3); // 将负数和正数对调，且将负数看成0, 输出：He                         
      ```                
   * 如果startIndex比endIndex大，则在提取子串之前会先对调这两个参数。                                           
      ```javascript
      alert(oStr.substring(9, 6)); // 第二个参数大于第一个参数，截取字符串前先对调参数位置，输出:can   
      ```                                     
      第二个参数大于第一个参数时，两个参数会对调位置，所以substring(9,6)等效于substring(6,9)。                                         
   如果startIndex和endIndex相等，则返回空字符。                                            
   如果只有一个startIndex参数，则返回字符串从startIndex位置开始到结尾之间所有字符串。
      ```javascript                                       
      alert(oStr.substring(6)); // 从第6个索引字符开始提取后面所有的字符，输出：can I help you?   
      ```                                      
                                                
### 2. substr(**startIndex \[,length\]**)                                                
   var str = "Hello, can I help you?";                                           
   * 用于从startIndex位置开始向后面截取不超过length个字符。                                           
      ```javascript
      alert(str.substr(1, 3)); // 从第二个字符开始提取后面不超过3个字符的子串， 输出：ell   
      ```                                      
   * 参数startIndex可以取正数或负数，                                             
      为负数时，则该负数的绝对值表示字符串的倒数第几个字符，                                          
      例如-1指最后一个字符，-2指倒数第二个字符，以此类推。                                         
      ```javascript
      alert(str.substr(-2, 3);  // 从倒数第二个字符开始提取后面不超过3个字符的子串， 输出：u?   
      ```                                       
   * length参数只能为非0正数，表示截取的字符个数，否则不能截取字符串；                                             
      ```javascript
      alert(str.substr(1, -3)); // length参数为负数，没有结果输出     
      ```                                   
   * 该参数可以省略，如果省略则表示从startIndex开始截取到字符串结尾的所有字符。                                             
      ```javascript
      alert(str.substr(6)); //  从第6个索引字符开始提取后面所有的字符，输出：can I help you?       
      ```                                  
                                                
### 3. slice(**(startIndex \[,endIndex\]**)                                              
   ```javascript
   var str = "Hello, can I help you?";  
   ```                                         
                                                
   * 用于截取并返回字符串索引值startIndex到endIndex-1之间的字符串。                                           
      ```javascript
      alert(str.slice(6)); // can I help you?                                          
      alert(str.slice(6, 9)); // can  
      ```                                        
   * 该方法和substring()的用法很类似，参数的含义                                             
      * 两个参数都可以为负数                                         
         ```javascript
         alert(str.slice(2, -3)); // llo, can I help y                                       
         alert(str.slice(-4)); //  you?                                       
         alert(str.slice(-4, -1)); // you   
         ```                                  
      * 第一个参数必须大于第二个参数                                        
         ```javascript
         alert(str.slice(9, 6)); // 没有输出                       
         ```               
   * 其他和substring()的完全一样，故在此不再赘述。                                            
                                                
使用substring()实现字符串的收缩和展开效果，具体代码如下所示：
  ```javascript   
   <!DOCTYPE html>                                             
   <html>                                             
      <head>                                          
         <meta charset="UTF-8">                                      
         <title>使用substring()实现字符串的收缩和展开</title>                                       
      </head>                                         
      <body>                                          
         <p>                                       
            <span>DJI大疆创新今日发布“御”Mavic2系列无人机，包括“御”Mavic2专业版及“御”Mavic2变焦版两款。大疆官方将“御”Mavic2系列定位为“便携航拍旗舰“，其延续了“御”Mavic Pro的折叠式机身设计，并将哈苏影像与光学变焦技术融入其中。</span>                                  
            ...<a href="javascript:;">>>收缩</a>                                   
         </p>                                      
         <script>                                     
            window.onload = function() {                                   
               var oP = document.getElementsByTagName('p')[0];                               
               var oSpan = document.getElementsByTagName('span')[0];                               
               var oA = document.getElmentsByTagName('a')[0];                                
               var str = oSpan.innerHTML;                               
               var onOff = true;                               
               oA.onclick = function() {                                
                  if(onOff) {                            
                     oSpan.innerHTML = str.substring(0, 27);                           
                     oA.innerHTML = '>>展开';                          
                                                
                  } else {                            
                     oSpan.innerHTML = str;                          
                     oA.innerHTML = '>>收缩';                          
                  }                             
               onOff = !onOff;                                 
               }                                
            }                                   
         </script>                                       
      </body>                                         
   </html>      
   ```                                      
   
   
## Demo页面
./20200507/atag.html

# 技术提升思路
自己先动手实现某个功能->不断丰富（渐进）

# 前端架构方式
1. 脚手架工具生成页面（模板）
从第一个页面开始->第二个页面 ->重复的部分抽象出来
灵活
前端页面平行/扁平
2. 架构：定义接口->实现 
C语言
依赖关系
从上至下

# 目前架构
webpack/vue/react -> node api -> 微服务（Go)
TS
egg



