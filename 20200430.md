# ES5继承与ES6继承的区别
ES6构造函数
6种实现


# 搜索框
["a", "b", "c"]  
["c", "a", "b"]  <- c  
["d", "c", "a", "b"] <- d  
length <= 5  

const arr = []  
const history = (value) =>该例子用到了decodeURIComponent（），后者是在客户端JavaScript定义的全局函数。（参见本书第三部分中的Global获取详细内容。）


# ES6 new Promise resolve是立刻调用么？
async
await
## 异步：现在与将来
* 很重要但常常被误解的一点是，如何表达和控制持续一段时间的程序行为。  
  这不仅仅是指从for循环开始到结束的过程，当然这也需要持续一段时间（几微秒或几毫秒）才能完成。   
  它是指程序的一部分现在运行，而另一部分则在将来运行——现在和将来之间有段间隙，在这段间隙中，程序没有活跃执行。  
* 所有重要的程序（特别是JavaScript程序）都需要通过这样或那样的方法来管理这段时间间隙，这时可能是
  * 在等待用户输入
  * 从数据库或文件系统中请求数据
  * 通过网络发送数据并等待响应                                            
  * 在以固定时间间隔执行重复<span class="s1">任务</span>（比如动画）  
在诸如此类的场景中，程序都需要管理这段时间间隙的状态。

* 事实上，程序中现在运行的部分和将来运行的部分之间的关系就是异步编程的核心。
* 从一开始，JavaScript就涉及异步编程。但是，多数JavaScript开发者从来没有认真思考过
  * 自己程序中的异步到底是如何出现的                                            
  * 以及其为什么会出现                                           
  * 也没有探索过处理异步的其他方法                                           
  一直以来，低调的回调函数就算足够好的方法了。目前为止，还有很多人坚持认为回调函数完全够用。   
为了满足这些需求，JavaScript的规模和复杂性也在持续增长，对异步的管理也越来越令人痛苦，这一切都迫切需要更强大、更合理的异步方法。 在接下来的几章中，我们会探讨各种新出现的JavaScript异步编程技术。

深入理解异步的概念及其在JavaScript中的运作模式。

### 分块的程序
  * 可以把JavaScript程序写在单个．js文件中，但是这个程序几乎一定是由多个块构成的。   
  * JavaScript程序总是至少分为两个块：                                            
    1. 第一块现在运行；                                          
      这些块中只有一个是现在执行，                                        
    2. 下一块将来运行，以响应某个事件。                                          
      其余的则会在将来执行。                                       
  * 尽管程序是一块一块执行的，但是所有这些块共享对程序作用域和状态的访问，所以对状态的修改都是在之前累积的修改之上进行的。                                           

  * 最常见的块单位是函数。                                           
    * 程序中将来执行的部分并不一定在现在运行的部分执行完之后就立即执行。   
      换句话说，现在无法完成的<span class="s1">任务</span>将会异步完成，因此并不会出现人们本能地认为会出现的或希望出现的阻塞行为。  
        ```javascript
        // ajax(..)是某个库中提供的某个Ajax函数                                       
        var data = ajax("http://some.url.1");                                       
        console.log(data);                                        
        // 啊哦！data通常不会包含Ajax结果    
        ```                                    
        * 标准Ajax请求不是同步完成的，这意味着ajax(..)函数还没有返回任何值可以赋给变量data。  
        如果ajax(..)能够阻塞到响应返回，那么data = ..赋值就会正确工作。                                        
        * 现在我们发出一个异步Ajax请求，然后在将来才能得到返回的结果。   
        从现在到将来的“等待”，最简单的方法（但绝对不是唯一的，甚至也不是最好的！）是使用一个通常称为回调函数的函数：
        ```javascript
        // ajax(..)是某个库中提供的某个Ajax函数                                       
        ajax("http://some.url.1", function myCallbackFunction(data) {                                       
          console.log(data);  // 耶！这里得到了一些数据！                                     
        });                
        ```                       
        * 可以发送同步Ajax请求。尽管技术上说是这样，但是，在任何情况下都不应该使用这种方式， 
        因为它会锁定浏览器UI（按钮、菜单、滚动条等），并阻塞所有的用户交互。这是一个可怕的想法，一定要避免。                                       
        但为了避免回调函数引起的混乱并不足以成为使用阻塞式同步Ajax的理由。                                       
    * 任何时候，只要把一段代码包装成一个函数，并指定它在响应某个事件（定时器、鼠标点击、Ajax响应等）时执行，你就是在代码中创建了一个将来执行的块，也由此在这个程序中引入了异步机制。  
      ```javascript
      function now() {                                          
        return 21;                                        
      }                                         
      function later() {                                          
        answer = answer * 2;                                        
        console.log("Meaning of life:", answer);                                        
      }                                         
      var answer = now();                                         
      setTimeout(later, 1000); // Meaning of life: 42                 
      ```                        
      这个程序有两个块：                                         
        1. 现在执行的部分     
          ```javascript                                  
          function now() {                                      
            return 21;                                    
          }                                     
          function later() { .. }                                     
          var answer = now();                                     
          setTimeout(later, 1000); // Meaning of life: 42                                 
          ```    
          现在这一块在程序运行之后就会立即执行。                                     
        2. 将来执行的部分         
          ```javascript                              
          answer = answer * 2;                                      
          console.log("Meaning of life:", answer);             
          ```                         
          但是，setTimeout(..)还设置了一个事件（定时）在将来执行，所以函数later()的内容会在之后的某个时间（从现在起1000毫秒之后）执行。                                     

### 异步控制台
  * 并没有什么规范或一组需求指定console.＊方法族如何工作——它们并不是JavaScript正式的一部分，而是由宿主环境（请参考本书的“类型和语法”部分）添加到JavaScript中的。 
    因此，不同的浏览器和JavaScript环境可以按照自己的意愿来实现，有时候这会引起混淆。  
  * 在某些条件下，某些浏览器的console.log(..)并不会把传入的内容立即输出。  
    出现这种情况的主要原因是，在许多程序（不只是JavaScript）中，I/O是非常低速的阻塞部分。                                         
    所以，（从页面/UI的角度来说）浏览器在后台异步处理控制台I/O能够提高性能，这时用户甚至可能根本意识不到其发生。                                         
    下面这种情景不是很常见，但也可能发生，从中（不是从代码本身而是从外部）可以观察到这种情况： 
    ```javascript
      var a = {                                       
        index: 1                                      
      }                                       
      // 然后                                       
      console.log(a); // ??                                       
      // 再然后                                        
      a.index++     
      ```                                  
      我们通常认为恰好在执行到console.log(..)语句的时候会看到a对象的快照，打印出类似于{ index: 1 }这样的内容，然后在下一条语句a.index++执行时将其修改，这句的执行会严格在a的输出之后。                                       
      多数情况下，前述代码在开发者工具的控制台中输出的对象表示与期望是一致的。      
      但是，这段代码运行的时候，浏览器可能会认为需要把控制台I/O延迟到后台，在这种情况下，等到浏览器控制台输出对象内容时，a.index++可能已经执行，因此会显示{ index: 2 }。  
      到底什么时候控制台I/O会延迟，甚至是否能够被观察到，这都是游移不定的。      
      如果在调试的过程中遇到对象在console.log(..)语句之后被修改，可你却看到了意料之外的结果，要意识到这可能是这种I/O的异步化造成的。                                          
      * 如果遇到这种少见的情况，                                        
        * 最好的选择是在JavaScript调试器中使用断点，而不要依赖控制台输出。  
        * 次优的方案是把对象序列化到一个字符串中，以强制执行一次“快照”，比如通过JSON.stringify(..)。                                     


### **事件循环**
  * 直到最近（ES6）, JavaScript才真正内建有直接的异步概念              
    前面提到的“直到最近”是指ES6从本质上改变了在哪里管理**事件循环**。   
    本来它几乎已经是一种正式的技术模型了，但现在ES6精确指定了**事件循环**的工作细节，这意味着在技术上将其纳入了JavaScript引擎的势力范围，而不是只由宿主环境来管理。    
    这个改变的一个主要原因是ES6中Promise的引入，因为这项技术要求对**事件循环**队列的调度运行能够直接进行精细控制                                         
    （参见1.4.3节中对setTimeout(..0)的讨论），具体内容会在第3章中介绍。                                          
  * 一旦有事件需要运行，**事件循环**就会运行，直到队列清空。  
    所有这些环境都有一个共同“点”（thread，也指线程。不论真假与否，这都不算一个很精妙的异步笑话），即                                          
    它们都提供了一种机制来处理程序中多个块的执行，  
    且执行每块时调用JavaScript引擎，                                       
    这种机制被称为**事件循环**。                                        
    * 换句话说，JavaScript引擎本身并没有时间的概念，只是一个按需执行JavaScript任意代码片段的环境。                                        
    * “事件”（JavaScript代码执行）调度总是由包含它的环境进行。    
      * 举例来说，如果你的JavaScript程序发出一个Ajax请求，从服务器获取一些数据， 
      * 那你就在一个函数（通常称为回调函数）中设置好响应代码，   
      * 然后JavaScript引擎会通知宿主环境：“嘿，现在我要暂停执行，你一旦完成网络请求，拿到了数据，就请调用这个函数。”   
      * 然后浏览器就会设置侦听来自网络的响应，拿到要给你的数据之后，就会把回调函数插入到**事件循环**，以此实现对这个回调的调度执行。                                      
  * **事件循环**的每一轮称为一个tick。                                           
  * 用户交互、IO和定时器会向事件队列中加入事件。                                           
  * 任意时刻，一次只能从队列中处理一个事件。                                            
    JavaScript引擎本身所做的只不过是在需要的时候，在给定的任意时刻执行程序中的单个代码块。  
    “需要”，谁的需要？这正是关键所在！                                        
    * JavaScript引擎并不是独立运行的，它运行在宿主环境中，                                       
      * 对多数开发者来说通常就是Web浏览器。                                     
      * 经过最近几年（不仅于此）的发展，JavaScript已经超出了浏览器的范围，进入了其他环境，  
        * 比如通过像Node.js这样的工具进入服务器领域。                                   
        * 实际上，JavaScript现如今已经嵌入到了从机器人到电灯泡等各种各样的设备中。  
  * 执行事件的时候，可能直接或间接地引发一个或多个后续事件。                                            
  * 什么是**事件循环**？                                            
    通过一段伪代码了解一下这个概念：  
    ```javascript                                        
    // eventLoop是一个用作队列的数组                                          
    // （先进，先出）                                          
    var eventLoop = [];                                         
    var event;                                          
    // “永远”执行                                         
    while(true) {                                         
      // 一次tick                                       
      if(eventLoop.length > 0) {                                        
        // 拿到队列中的下一个事件                                      
        event = eventLoop.shift();                                      
        // 现在，执行下一个事件                                     
        try {                                     
          event();                                    
        }                                     
        catch(err) {                                      
          reportError(err);                                   
        }                                     
      }                                       
    }       
    ```                                  
    有一个用while循环实现的持续运行的循环，循环的每一轮称为一个tick。                                         
    对每个tick而言，如果在队列中有等待事件，那么就会从队列中摘下一个事件并执行。 
    这些事件就是你的回调函数。                                         

    * 一定要清楚，setTimeout(..)并没有把你的回调函数挂在**事件循环**队列中。    
      * 它所做的是设定一个定时器。                                       
      * 当定时器到时后，环境会把你的回调函数放在**事件循环**中，                                        
      * 这样，在未来某个时刻的tick会摘下并执行这个回调。                                        
    * 如果这时候**事件循环**中已经有20个项目了会怎样呢？                                        
      你的回调就会等待。                                     
      它得排在其他项目后面——通常没有抢占式的方式支持直接将其排到队首。                                     
      这也解释了为什么setTimeout(..)定时器的精度可能不高。                                     
      大体说来，只能确保你的回调函数不会在指定的时间间隔之前运行，但可能会在那个时刻运行，也可能在那之后运行，要根据事件队列的状态而定。                                     
    所以换句话说就是，程序通常分成了很多小块，在**事件循环**队列中一个接一个地执行。 
    严格地说，和你的程序不直接相关的其他事件也可能会插入到队列中。                                       

### <span class="s4">并行</span>线程
  * 术语“异步”和“<span class="s4">并行</span>”常常被混为一谈，但实际上它们的意义完全不同。                                           
    * 异步是关于现在和将来的时间间隙                                         
    * <span class="s4">并行</span>是关于能够同时发生的事情    
  * <span class="s4">并行</span>线程的交替执行和异步事件的交替调度，其粒度是完全不同的。
      
  * 示例   
  ```javascript
        var a = 20;                                       
        function foo() {                                        
          a = a + 1;                                      
        }                                       
        function bar() {                                        
          a = a * 2;                                      
        }                                       
        // ajax(..)是某个库中提供的某个Ajax函数                                       
        ajax("http://some.url.1", foo);                                       
        ajax("http://some.url.2", bar);    
   ```                                       
  * <span class="s4">并行</span>计算最常见的工具就是进程和线程。                                            
    进程和线程独立运行，并可能同时运行在不同的处理器，甚至不同的计算机上                                          
    但多个线程能够共享单个进程的内存     
    但如果是在<span class="s4">并行</span>系统中，同一个程序中可能有两个不同的线程在运转，这时很可能就会得到不确定的结果。
    如果共享同一数据的JavaScript事件<span class="s4">并行</span>执行的话，那么问题就变得更加微妙了。                                
    * 考虑foo()和bar()中代码运行的线程分别执行的是以下两段伪代码<span class="s1">任务</span>，然后思考一下如果它们恰好同时运行的话会出现什么情况。
      ```javascript                                     
      线程1（X和Y是临时内存地址）：                                      
        foo():                                    
          a. 把a的值加载到X                                 
          b. 把1保存在Y                                 
          c. 执行X加Y，结果保存在X                                 
          d. 把X的值保存在a                                 
      线程2（X和Y是临时内存地址）：                                      
        bar():                                    
          a. 把a的值加载到X                                 
          b. 把2保存在Y                                 
          c. 执行X乘Y， 结果保存在X                                  
          d. 把X的值保存在a   
      ```                              
      假设两个线程<span class="s4">并行</span>执行。                                     
      你可能已经发现了这个程序的问题，是吧？                                     
      它们在临时步骤中使用了共享的内存地址X和Y。                                      
    * 如果按照以下步骤执行，最终结果将会是什么样呢？  
      ```javascript
      1a（把a的值加载到X      ==>20）                                   
      2a（把a的值加载到X      ==>20）                                   
      1b（把1保存在Y      ==>1）                                    
      2b（把2保存在Y      ==>2)                                    
      1c（执行X加Y，结果保存在X      =>22）                                    
      1d（把X的值保存在a      ==> 22）                                    
      2c（执行X乘Y，结果保存在X      ==> 44)                                    
      2d（把X的值保存在a      ==> 44）    
      ```                                
    * 但如果按照以下顺序执行呢？                                     
      ```javascript
      1a（把a的值加载到X      ==>20）                                   
      2a（把a的值加载到X      ==>20）                                   
      2b（把2保存在Y      ==>2)                                    
      1b（把1保存在Y      ==>1）                                    
      2c（执行X乘Y，结果保存在X      ==> 20)                                    
      1c（执行X加Y，结果保存在X      =>21）                                    
      1d（把X的值保存在a      ==> 22）                                    
      2d（把X的值保存在a      ==> 44）  
      ```                                  
    * 多线程编程是非常复杂的。                                      
      因为如果不通过特殊的步骤来防止这种中断和交错运行的话，可能会得到出乎意料的、不确定的行为，通常这很让人头疼。                                    
     
  * 与之相对的是，**事件循环**把自身的工作分成一个个<span class="s1">任务</span>并顺序执行，不允许对共享内存的<span class="s4">并行</span>访问和修改。                                           
    * 通过分立线程中彼此合作的**事件循环**，<span class="s4">并行</span>和顺序执行可以共存。  
        * 举例来说：                                       
            ```javascript                                            
            funcstion later() {                                         
              answer = answer * 2;                                        
              console.log("Meaning of life:", answer);                                        
            }            
            ```                             
           尽管later()的所有内容被看作单独的一个**事件循环**队列表项，                                         
           但如果考虑到这段代码是运行在一个线程中，实际上可能有很多个不同的底层运算。 
          * 比如，answer = answer ＊ 2需要先加载answer的当前值                                      
          * 然后把2放到某处并执行乘法，                                        
          * 取得结果之后保存回answer                                       
        * 在单线程环境中，线程队列中的这些项目是底层运算确实是无所谓的，因为线程本身不会被中断。
        * 根据JavaScript的单线程运行特性，                                       
        如果foo()运行在bar()之前，a的结果是42，                                      
        而如果bar()运行在foo()之前的话，a的结果就是41。   
    * JavaScript从不跨线程共享数据，这意味着不需要考虑这一层次的不确定性。   
    但是这并不意味着JavaScript总是确定性的。                                       
    回忆一下前面提到的，foo()和bar()的相对顺序改变可能会导致不同结果（41或42）。   
   可能目前还不是很明显，但并不是所有的不确定性都是有害的。这有时无关紧要，但有时又是要刻意追求的结果。关于这一点，本章和后面几章会给出更多示例。                                        
        
### 完整运行
  * 由于JavaScript的单线程特性，foo()（以及bar()）中的代码具有原子性。    
    也就是说，一旦foo()开始运行，它的所有代码都会在bar()中的任意代码运行之前完成，或者相反。   
    这称为完整运行（run-to-completion）特性。                                         
  * 实际上，如果foo()和bar()中的代码更长，完整运行的语义就会更加清晰，比如： 
    ```javascript
    // 块1：                                          
    var a = 1;                                          
    var b = 2;                                          

    function foo() {                                          
      // 块2：                                        
      a++;                                        
      b = b * a;                                        
      a = b + 3;                                        
    }                                         
    function bar() {                                          
      // 块3：                                        
      b--;                                        
      a = 8 + b;                                        
      b = a * 2;                                        
    }                                         
    // ajax(..)是某个库中提供的某个Ajax函数                                         
    ajax("http://some.url.1", foo);                                         
    ajax("http://some.url.2", bar);  
    ```                                       
    由于foo()不会被bar()中断，bar()也不会被foo()中断，所以这个程序只有两个可能的输出，取决于这两个函数哪个先运行  
    如果存在多线程，且foo()和bar()中的语句可以交替运行的话，可能输出的数目将会增加不少！   
    块1是同步的（现在运行）                                          
    块2和块3是异步的（将来运行），也就是说，它们的运行在时间上是分隔的。                                         
    块2和块3哪个先运行都有可能，所以这个程序有两个可能输出。    
      输出1：            
      ```javascript                                     
      var a = 1;                                        
      var b = 2;                                        

      // foo()                                        
      a++;                                        
      b = b * a;                                        
      a = b + 3;                                        

      // bar()                                        
      b--;                                        
      a = 8 + b;                                        
      b = a * 2;                                        

      a; // 11                                        
      b; // 22   
      ```                                     
      输出2：
      ```javascript                                        
      var a = 1;                                        
      var b = 2;                                        

      // bar()                                        
      b--;                                        
      a = 8 + b;                                        
      b = a * 2;                                        

      // foo()                                        
      a++;                                        
      b = b * a;                                        
      a = b + 3;                                        

      a; // 183                                       
      b; // 180   
      ```                                    

  * 同一段代码有两个可能输出意味着还是存在不确定性！                                            
    但是，这种不确定性是在函数（事件）顺序级别上，                                         
    而不是多线程情况下的语句顺序级别（或者说，表达式运算顺序级别）。                                          
    换句话说，这一确定性要高于多线程情况。                                         

  * 在JavaScript的特性中，这种函数顺序的不确定性就是通常所说的<span class="s2">竞态条件</span>（race condition）,                                           
     foo()和bar()相互竞争，看谁先运行。                                         
    具体来说，因为无法可靠预测a和b的最终结果，所以才是<span class="s2">竞态条件</span>。   
  如果JavaScript中的某个函数由于某种原因不具有完整运行特性，那么可能的结果就会多得多，对吧？ 
    实际上，ES6就引入了这么一个东西（参见第4章），现在还不必为此操心，以后还会再探讨这一部分！ 

### <span class="s5">并发</span>
* <span class="s5">并发</span>是指两个或多个事件链随时间发展交替执行，以至于从更高的层次来看，就像是同时在运行（尽管在任意时刻只处理一个事件）。  
* 现在让我们来设想一个展示状态更新列表（比如社交网络新闻种子）的网站，其随着用户向下滚动列表而逐渐加载更多内容。  
  要正确地实现这一特性，需要（至少）两个独立的“进程”同时运行（也就是说，是在同一段时间内，并不需要在同一时刻）。     
  这里的“进程”之所以打上引号，是因为这并不是计算机科学意义上的真正操作系统级进程。    
  这是虚拟进程，或者<span class="s1">任务</span>，表示一个逻辑上相关的运算序列。                                             
  之所以使用“进程”而不是“<span class="s1">任务</span>”，是因为从概念上来讲，“进程”的定义更符合这里我们使用的意义。                                             
   1. 第一个“进程”在用户向下滚动页面触发onscroll事件时响应这些事件（发起Ajax请求要求新的内容）。   
   2. 第二个“进程”接收Ajax响应（把内容展示到页面）。                                          
显然，如果用户滚动页面足够快的话，在等待第一个响应返回并处理的时候可能会看到两个或更多onscroll事件被触发，因此将得到快速触发彼此交替的onscroll事件和Ajax响应事件。                                             
* 两个或多个“进程”同时执行就出现了<span class="s5">并发</span>，不管组成它们的单个运算是否<span class="s4">并行</span>执行（在独立的处理器或处理器核心上同时运行）。    
* 可以把<span class="s5">并发</span>看作“进程”级（或者<span class="s1">任务</span>级）的<span class="s4">并行</span>，与运算级的<span class="s4">并行</span>（不同处理器上的线程）相对。                                            
* <span class="s5">并发</span>也引出了这些“进程”之间可能的彼此交互的概念。我们会在后面介绍。                                          
在给定的时间窗口内（用户滚动页面的几秒钟内），我们看看把各个独立的“进程”表示为一系列事件/运算是什么样的：

    ```javascript                                            
    “进程”1（onscroll事件）：                                          
        onscroll，请求1                                      
        onscroll，请求2                                      
        onscroll，请求3                                      
        onscroll，请求4                                      
        onscroll，请求5                                      
        onscroll，请求6                                      
        onscroll，请求7                                      
    “进程”2（Ajax响应事件）：                                          
        响应1                                     
        响应2                                     
        响应3                                     
        响应4                                     
        响应5                                     
        响应6                                     
        响应7           
    ```           
很可能某个onscroll事件和某个Ajax响应事件恰好同时可以处理。举例来说，假设这些事件的时间线是这样的： 
```javascript  
onscroll，请求1                                      
onscroll，请求2          响应1                                     
onscroll，请求3          响应2                                     
响应3                                     
onscroll，请求4                                      
onscroll，请求5                                      
onscroll，请求6          响应4                                     
onscroll，请求7                                      
响应6                                     
响应5                                     
响应7           
```                          
本章前面介绍过**事件循环**的概念，JavaScript一次只能处理一个事件，所以要么是onscroll，请求2先发生，要么是响应1先发生，但是不会严格地同时发生。                                       
下面列出了**事件循环**队列中所有这些交替的事件：       
```javascript                                   
onscroll，请求1          <---进程1启动                                     
onscroll，请求2
响应1                    <---进程2启动                                      
onscroll，请求3
响应2                                     
响应3                                     
onscroll，请求4                                      
onscroll，请求5                                      
onscroll，请求6
响应4                                     
onscroll，请求7          <---进程1结束                                     
响应6                                     
响应5                                     
响应7                    <---进程2结束       
```                               
“进程”1和“进程”2<span class="s5">并发</span>运行（<span class="s1">任务</span>级<span class="s4">并行</span>），但是它们的各个事件是在**事件循环**队列中依次运行的。                                     
单线程**事件循环**是<span class="s5">并发</span>的一种形式（当然还有其他形式，后面会介绍）。


### <span class="s5">并发</span>合作方式
#### 非交互                                           
两个或多个“进程”在同一个程序内<span class="s5">并发</span>地交替运行它们的步骤/事件时，如果这些<span class="s1">任务</span>彼此不相关，就不一定需要交互。                                          
如果进程间没有相互影响的话，不确定性是完全可以接受的。   
```javascript                                      
var res = {};                                         
function foo(results) {                                         
  res.foo = results;                                        
}                                         
function bar(results) {                                         
  res.bar = results;                                        
}                                         
// ajax(..)是某个库提供的某个Ajax函数                                          
ajax("http://some.url.1", foo);                                         
ajax("http://some.url.2", bar);  
```                                       
foo()和bar()是两个<span class="s5">并发</span>执行的“进程”，按照什么顺序执行是不确定的。                                          
但是，我们构建程序的方式使得无论按哪种顺序执行都无所谓，因为它们是独立运行的，不会相互影响。                                          
这并不是<span class="s2">竞态条件</span>bug，因为不管顺序如何，代码总会正常工作。                                          
  
通常需要对这些<span class="s5">并发</span>执行的“进程”（有别于操作系统中的进程概念）进行某种形式的交互协调，比如   
#### 需要确保执行顺序或者需要防止竞态出现——交互                                          
通过共享作用域中的值进行交互                                          
更常见的情况是，<span class="s5">并发</span>的“进程”需要相互交流，通过作用域或DOM间接交互。                                        
如果出现这样的交互，就需要对它们的交互进行协调以避免竞态的出现。                                        
1. 两个<span class="s5">并发</span>的“进程”通过隐含的顺序相互影响，这个顺序有时会被破坏： 
  ```javascript                                        
  var res = [];                                     
  function response(data) {                                     
    res.push(data);                                   
  }                                     
  ajax("http://some.url.1", response);                                      
  ajax("http://some.url.2", response);   
  ```                                   
  这里的<span class="s5">并发</span>“进程”是这两个用来处理Ajax响应的response()调用。它们可能以任意顺序运行。   
  我们假定期望的行为是res\[0\]中放调用"`http://some.url.1`"的结果，res\[1\]中放调用"`http://some.url.2`"的结果。  
  有时候可能是这样，但有时候却恰好相反，这要视哪个调用先完成而定。                                      
  这种不确定性很有可能就是一个<span class="s2">竞态条件</span>bug。                                      
   * 在这些情况下，你对可能做出的假定要持十分谨慎的态度。                                        
    比如，开发者可能会观察到对"`http://some.url.2`"的响应速度总是显著慢于对"`http://some.url.1`"的响应，这可能是由它们所执行<span class="s1">任务</span>的性质决定的（比如，一个执行数据库<span class="s1">任务</span>，而另一个只是获取静态文件），所以观察到的顺序总是符合预期。                                      
    即使两个请求都发送到同一个服务器，也总会按照固定的顺序响应，但对于响应返回浏览器的顺序，却没有人可以真正保证。                                     
   * 可以协调交互顺序来处理这样的<span class="s2">竞态条件</span>：        
      ```javascript                                
      var res = [];                                     
      function response(data) {                                     
        if(data.url == "http://some.url.1") {                                   
          res[0] = data;                                  
        } else if(data.url == "http://some.url.2") {                                    
          res[1] = data;                                  
        }                                   
      ajax("http://some.url.1", response);                                      
      ajax("http://some.url.2", response);  
      ```                                    
  不管哪一个Ajax响应先返回，我们都要通过查看data.url（当然，假定从服务器总会返回一个！）判断应该把响应数据放在res数组中的什么位置上。                                     
  res[0]总是包含"`http://some.url.1`"的结果，res[1]总是包含"`http://some.url.2`"的结果。  
  通过简单的协调，就避免了<span class="s2">竞态条件</span>引起的不确定性。                                      
2. 从这个场景推出的方法也可以应用于多个<span class="s5">并发</span>函数调用通过共享DOM彼此之间交互的情况， 
  比如一个函数调用更新某个`<div>`的内容，另外一个更新这个`<div>`的风格或属性（比如使这个DOM元素一有内容就显示出来）。                                      
  可能你并不想在这个DOM元素在拿到内容之前显示出来，                                      
  所以这种协调必须要保证正确的交互顺序。                                     
3. 有些<span class="s5">并发</span>场景如果不做协调，就总是（并非偶尔）会出错。考虑： 
  ```javascript                                       
  var a, b;                                     
  function foo(x) {                                     
    a = x * 2;                                    
    baz();                                    
  }                                     
  function bar(y) {                                     
    b = y * 2;                                    
    baz();                                    
  }                                     
  function baz() {                                      
    console.log(a + b);                                   
  }                                     
  ajax("http://some.url.1", foo);                                     
  ajax("http://some.url.2", bar); 
  ```                                    
  在这个例子中，无论foo()和bar()哪一个先被触发，总会使baz()过早运行（a或者b仍处于未定义状态）；                                     
  但对baz()的第二次调用就没有问题，因为这时候a和b都已经可用了。                                      
  * 要解决这个问题有多种方法。这里给出了一种简单方法：  
    ```javascript                                    
    var a, b;                                   
    function foo(x) {                                   
      a = x * 2;                                  
      if( a && b) {                                 
        baz();                                
      }                                 
    }                                   
    function bar(y) {                                   
      b = y * 2;                                  
      if(a && b) {                                  
        baz();                                
      }                                 
    }                                   
    function baz() {                                    
      console.log(a + b);                                 
    }                                   
    ajax("http://some.url.1", foo);                                   
    ajax("http://some.url.2", bar);  
    ```                                 
    包裹baz()调用的条件判断if (a && b)传统上称为门（gate），我们虽然不能确定a和b到达的顺序，但是会等到它们两个都准备好再进一步打开门（调用baz()）。                                   
4. 另一种可能遇到的<span class="s5">并发</span>交互条件有时称为竞态（race），但是更精确的叫法是门闩（latch）。  
  它的特性可以描述为“只有第一名取胜”。                                     
  在这里，不确定性是可以接受的，因为它明确指出了这一点是可以接受的：需要“竞争”到终点，且只有唯一的胜利者。 
  ```javascript 
  var a;                                      
  function foo(x) {                                     
    a = x * 2;                                    
    baz();                                    
  }                                     
  function bar(x) {                                     
    a = x / 2;                                    
    baz();                                    
  }                                     
  function baz() {                                      
    console.log(a);                                   
  }                                     
  ajax("http://some.url.1", foo);                                     
  ajax("http://some.url.2", bar);    
  ```                                 
  不管哪一个（foo()或bar()）后被触发，都不仅会覆盖另外一个给a赋的值，也会重复调用baz()（很可能并不是想要的结果）。
  * 可以通过一个简单的门闩协调这个交互过程，只让第一个通过： 
      ```javascript                                      
      var a;                                    
      function foo(x) {                                   
        if(!a) {                                  
          a = x * 2;                                
          baz();                                
        }                                 
      }                                   
      function bar(x) {                                   
        if(!a) {                                  
          a = x / 2;                                
          baz();                                
        }                                 
      }                                   
      function baz() {                                    
        console.log( a );                                 
      }                                   
      ajax("http://some.url.1", foo);                                   
      ajax("http://some.url.2", bar);    
      ```                               
  条件判断if (! a)使得只有foo()和bar()中的第一个可以通过，第二个（实际上是任何后续的）调用会被忽略。也就是说，第二名没有任何意义！                                   
出于简化演示的目的，在所有这些场景中，我们一直都使用了全局变量，但这对于此处的论证完全不是必需的。  
只要相关的函数（通过作用域）能够访问到这些变量，就会按照预期工作。                                       
依赖于词法作用域变量（参见本系列的《你不知道的JavaScript（上卷）》的“作用域和闭包”部分），实际上前面例子中那样的全局变量，对于这些类别的<span class="s5">并发</span>协调是一个明显的负面因素。                                       
随着后面几章内容的展开，我们会看到还有其他种类的更清晰的协调方式。                                       

#### 这些“进程”也可以通过把自身分割为更小的块，以便其他“进程”插入进来。——协作                                         
还有一种<span class="s5">并发</span>合作方式，称为<span class="s3">并发协作</span>（cooperative concurrency）。                                       
这里的重点不再是通过共享作用域中的值进行交互（尽管显然这也是允许的！）。   
这里的目标是取到一个长期运行的“进程”，并将其分割成多个步骤或多批<span class="s1">任务</span>，使得其他<span class="s5">并发</span>“进程”有机会将自己的运算插入到**事件循环**队列中交替运行。                                        
考虑一个需要遍历很长的结果列表进行值转换的Ajax响应处理函数。    
  ```javascript                                     
  var res = [];                                     
  // response(..)从Ajax调用中取得结果数组                                     
  function response(data) {                                     
    // 添加到已有的res数组                                    
    res = res.concat(                                   
      // 创建一个新的变换数组把所有data值加倍                                 
      data.map(function (val) {                                 
        return val * 2;                               
      })                                  
    )                                   
  }                                     
  // ajax(..)是某个库中提供的某个Ajax函数                                     
  ajax("http://some.url.1", response);                                      
  ajax("http://some.url.2", response);   
  ```                                   
  * 如果"`http://some.url.1`"首先取得结果，那么整个列表会立刻映射到res中。  
  如果记录有几千条或更少，这不算什么。
  但是如果有像1000万条记录的话，就可能需要运行相当一段时间了  
     * 在高性能笔记本上需要几秒钟
     * 在移动设备上需要更长时间，等等                                      
  * 这样的“进程”运行时，页面上的其他代码都不能运行，包括不能有其他的response(..)调用或UI刷新，甚至是像滚动、输入、按钮点击这样的用户事件。这是相当痛苦的。                                     
  * 所以，要创建一个协作性更强更友好且不会霸占**事件循环**队列的<span class="s5">并发</span>系统，你可以异步地批处理这些结果。每次处理之后返回****事件循环****，让其他等待事件有机会运行。                                       
  这里给出一种非常简单的方法：       
  ```javascript                                
  var res = [];                                     
  // response(..)从Ajax调用中取得结果数组                                     
  function response(data) {                                     
    // 一次处理1000个                                    
    var chunk = data.splice(0, 1000);                                   
    // 添加到已有的res数组                                    
    res = res.concat(                                   
      chunk.map(function(val) {                                 
        return val * 2;                               
      })                                  
    );                                    
    // 还有剩下的需要处理吗？                                    
    if(data.length > 0) {                                   
      // 异步调度下一次批处理                                 
      setTimeout(function() {                                 
        response(data)                                
      }, 0);                                  
    }                                   
  }                                     
  ajax("http://some.url.1", response);                                      
  ajax("http://some.url.2", response);  
  ```                                    
  我们把数据集合放在最多包含1000条项目的块中。                                      
  * 这样，我们就确保了“进程”运行时间会很短，即使这意味着需要更多的后续“进程”，因为**事件循环**队列的交替运行会提高站点/App的响应（性能）。                                   
  * 当然，我们并没有协调这些“进程”的顺序，所以结果的顺序是不可预测的。                                      
  * 如果需要排序的话，就要使用和前面提到类似的交互技术，或者本书后面章节将要介绍的技术。   
  * 这里使用setTimeout(..0)（hack）进行异步调度  
    基本上它的意思就是“把这个函数插入到当前**事件循环**队列的结尾处”。                                      
    严格说来，setTimeout(..0)并不直接把项目插入到**事件循环**队列。  
    定时器会在有机会的时候插入事件。                                   
    * 举例来说，两个连续的setTimeout(..0)调用不能保证会严格按照调用顺序处理，所以各种情况都有可能出现，比如定时器漂移，在这种情况下，这些事件的顺序就不可预测。                                    
    * 在Node.js中，类似的方法是process.nextTick(..)。  
    尽管它们使用方便（通常性能也更高），但并没有（至少到目前为止）直接的方法可以适应所有环境来确保异步事件的顺序。                                    
    下一小节我们会深入讨论这个话题。   

### <span class="s1">任务</span>
  在ES6中，有一个新的概念建立在**事件循环**队列之上，叫作<span class="s1">任务</span>队列（jobqueue）。                                            
  这个概念给大家带来的最大影响可能是Promise的异步特性（参见第3章）。                                           
  遗憾的是，目前为止，这是一个没有公开API的机制，因此要展示清楚有些困难。所以我们目前只从概念上进行描述，等到第3章讨论Promise的异步特性时，你就会理解这些动作是如何协调和处理的。                                           
  * **事件循环**队列类似于一个游乐园游戏：玩过了一个游戏之后，你需要重新到队尾排队才能再玩一次。                                            
  * <span class="s1">任务</span>队列类似于玩过了游戏之后，插队接着继续玩。  
    * 对于<span class="s1">任务</span>队列最好的理解方式就是，它是挂在**事件循环**队列的每个tick之后的一个队列。                                           
      在**事件循环**的每个tick中，可能出现的异步动作不会导致一个完整的新事件添加到**事件循环**队列中，而会在当前tick的<span class="s1">任务</span>队列末尾添加一个项目（一个<span class="s1">任务</span>）。                                         
      这就像是在说：“哦，这里还有一件事将来要做，但要确保在其他任何事情发生之前就完成它。”                                         
    * 一个<span class="s1">任务</span>可能引起更多<span class="s1">任务</span>被添加到同一个队列末尾。                                          
    所以，理论上说，<span class="s1">任务</span>循环（job loop）可能无限循环（一个<span class="s1">任务</span>总是添加另一个<span class="s1">任务</span>，以此类推），进而导致程序的饿死，无法转移到下一个**事件循环**tick。  
    从概念上看，这和代码中的无限循环（就像while(true)..）的体验几乎是一样的。                                         
    * <span class="s1">任务</span>和setTimeout(..0) hack的思路类似，但是其实现方式的定义更加良好，对顺序的保证性更强：尽可能早的将来。                                          
  设想一个调度<span class="s1">任务</span>（直接地，不要hack）的API，称其为schedule(..)。考虑：  
    ```javascript                                           
    console.log("A");                                         
    setTimeout(function() {                                         
      console.log("B");                                       
    }, 0);                                          
    // 理论上的“<span class="s1">任务</span>API”                                          
    schedule(function() {                                         
      console.log("C");                                       
      schedule(function() {                                       
        console.log("D");                                     
      });                                       
    });          
    ```                               
    实际打印的结果是A C D B。                                          
      因为<span class="s1">任务</span>处理是在当前**事件循环**tick结尾处，                                        
      且定时器触发是为了调度下一个**事件循环**tick（如果可用的话！）。                                        
    在第3章中，我们将会看到，Promise的异步特性是基于<span class="s1">任务</span>的，所以一定要清楚它和**事件循环**特性的关系。                                         

### 语句顺序

* 代码中语句的顺序和JavaScript引擎执行语句的顺序并不一定要一致。                                            
这门语言的规则和语法已经从程序的角度在语序方面规定了可预测和非常可靠的特性。     
所以，接下来我们要讨论的内容你应该无法在自己的JavaScript程序中观察到。   
* 如果你观察到了类似于我们将要展示的编译器对语句的重排序，
   * 那么这很明显违反了规范，而这一定是由所使用的JavaScript引擎中的bug引起的——该bug应该被报告和修正！                                           
   * 但是更可能的情况是，当你怀疑JavaScript引擎做了什么疯狂的事情时，实际上却是你自己代码中的bug（可能是<span class="s2">竞态条件</span>）引起的。                                           
所以首先要检查自己的代码，并且要反复检查。   
通过使用断点和单步执行一行一行地遍历代码，JavaScript调试器就是用来发现这样bug的最强大工具。
* 重点是，只要这个重新排序是不可见的，一切都没问题。   
  ```javascript 
  var a, b;                                         
  a = 10;                                         
  b = 30;                                         

  a = a + 1;                                          
  b = b + 1;                                          

  console.log(a + b); // 42          
  ```                               
  这段代码中没有显式的异步（除了前面介绍过的很少见的异步I/O!），所以很可能它的执行过程是从上到下一行行进行的。                                          
  JavaScript引擎在编译这段代码之后（是的，JavaScript是需要编译的）可能会发现通过（安全地）重新安排这些语句的顺序有可能提高执行速度。  
                                           
  * 比如，引擎可能会发现，其实这样执行会更快：       
      ```javascript                                     
      var a, b;                                       
    
      a = 10;                                       
      a++                                       
    
      b = 30;                                       
      b++;                                        
    
      console.log(a + b); // 42    
      ```                                   
  * 或者这样：              
      ```javascript                            
      var a, b;                                       
      
      a = 11;                                       
      b = 31;                                       
      
      console.log(a + b); // 42    
      ```                                   
  * 或者甚至这样：       
      ```javascript                                   
      // 因为a和b不会被再次使用                                       
      // 我们可以inline，从而完全不需要它们！                                        
      console.log( 42 ); // 42    
      ```                                    
  前面的所有情况中，JavaScript引擎在编译期间执行的都是安全的优化，最后可见的结果都是一样的。                                            
* 但是这里有一种场景，其中特定的优化是不安全的，因此也是不允许的（当然，不用说这其实也根本不能称为优化）：  
  ```javascript 
  var a, b;                                       
  a = 10;                                       
  b = 30;                                       

  // 我们需要a和b处于递增之前的状态！                                        
  console.log(a * b); // 300                                        

  a = a + 1;                                        
  b = b + 1;                                        

  console.log(a + b); // 42   
  ```                                    
* 还有其他一些例子，其中编译器重新排序会产生可见的副作用（因此必须禁止），比如    
  会产生副作用的函数调用（特别是getter函数）                                        
  ES6代理对象（参考本系列的《你不知道的JavaScript（下卷）》的“ES6 &Beyond”部分）。                       
  ```javascript                 
  function foo() {                                        
    console.log( b );                                     
    return 1;                                     
  }                                       

  var a, b, c;                                        

  // ES5.1 getter字面量语法                                        
  c = {                                       
    get bar() {                                     
      console.log(a);                                   
      return 1;                                   
    }                                     
  };                                        

  a = 10;                                       
  b = 30;                                       
  a += foo();  // 30                                        
  b += c.bar;  // 11                                        

  console.log(a + b);  // 42    
  ```                                    
  如果不是因为代码片段中的语句console.log(..)（只是作为一种方便的形式说明可见的副作用）, JavaScript引擎如果愿意的话，本来可以自由地把代码重新排序如下：          
  ```javascript                               
  // ...                                        
  a = 10 + foo();                                       
  b = 30 + c.bar;                                       
  // ...       
  ```        

                         
* 尽管JavaScript语义让我们不会见到编译器语句重排序可能导致的噩梦，这是一种幸运，但是代码编写的方式（从上到下的模式）和编译后执行的方式之间的联系非常脆弱，理解这一点也非常重要。                                        
编译器语句重排序几乎就是<span class="s5">并发</span>和交互的微型隐喻。                                       
作为一个一般性的概念，清楚这一点能够使你更好地理解异步JavaScript代码流问题。                                       



## 回调
### 回调函数是JavaScript异步的基本单元。                   
  回调是这门语言中最基础的异步模式。                 
  到目前为止，回调是编写和处理JavaScript程序异步逻辑的最常用方式。                 
  无数JavaScript程序，甚至包括一些最为高深和复杂的，所依赖的异步基础也仅限于回调（当然，它们使用了第1章介绍的各种并发交互模式）。                 
  回调函数是JavaScript的异步主力军，并且它们不辱使命地完成了自己的任务。                  
### 通过回调表达程序异步和管理并发的两个主要缺陷：
  但是随着JavaScript越来越成熟，对于异步编程领域的发展，回调已经不够用了。                   
  回调函数也不是没有缺点。                  
  只有理解了某种抽象的目标和原理，才能有效地应用这种抽象机制。                  
  回调函数可以实现所有你想要的功能，但是你需要努力才行。这些努力通常比你追踪这样的代码能够或者应该付出的要多得多。 
  本章将深入探讨这两点，以便弄懂为什么更高级的异步模式（后续章节和附录B中将会讨论）是必需和备受期待的。       
#### 1. 缺乏顺序性
顺序的大脑  

大脑对于事情的计划方式是线性的、阻塞的、单线程的语义，但是回调表达异步流程的方式是非线性的、非顺序的，这使得正确推导这样的代码难度很大。难于理解的代码是坏代码，会导致坏bug。                  
我们需要一种更同步、更顺序、更阻塞的的方式来表达异步，就像我们的大脑一样。               

#####  continuation                
第1章中给出的异步回调的例子，为了突出重点，以下稍作了修改： 
```javascript             
// A            
ajax("..", function(..) {           
  // C          
});           
// B            
// A和// B表示程序的前半部分（也就是现在的部分）              
前半部分立刻执行，然后是一段时间不确定的停顿。           
// C标识了程序的后半部分（也就是将来的部分）。 
```            
在未来的某个时刻，如果Ajax调用完成，程序就会从停下的位置继续执行后半部分。           
回调函数包裹或者说封装了程序的延续（continuation）。            
让我们进一步简化这段代码：   
```javascript          
// A            
setTimeout(function() {           
  // C          
}, 1000);           
// B      
```      
思考一下你自己会如何（向对JavaScript运作机制不甚了解的某位人士）描述这段程序的运行方式。然后试着把你的描述大声说出来。            
这种不匹配既微妙又显著，也正是理解回调作为异步表达和管理方式的缺陷的关键所在。           
  一旦我们以回调函数的形式引入了单个continuation（或者几十个，就像很多程序所做的那样！），我们就容许了大脑工作方式和代码执行方式的分歧。         
  一旦这两者出现分歧（这远不是这种分歧出现的唯一情况，我想你明白这一点！），我们就得面对这样一个无法逆转的事实：代码变得更加难以理解、追踪、调试和维护。    

* 我们最高级的大脑功能是以并行多线程的形式运行的吗？                
  答案可能出乎你的意料：很可能并不是这样。              
  我们更多是单任务执行者。实际上，在任何特定的时刻，我们只能思考一件事情。              
  我们在讨论的是此时处于意识前端的那些任务。             
  我们在假装并行执行多个任务时，实际上极有可能是在进行快速的上下文切换              
    我们是在两个或更多任务之间快速连续地来回切换，同时处理每个任务的微小片段。           
    我们切换得如此之快，以至于对外界来说，我们就像是在并行地执行所有任务。           
  这听起来是不是和异步事件并发机制（比如JavaScript中的形式）很相似呢              
  我们大脑的工作方式有点类似于**事件循环**队列。             
    我不会在每次可能被打断的时候都转而投入到其他“进程”中。            
    但是，中断的发生经常频繁到让我觉得我的大脑几乎是不停地切换到不同的上下文（即“进程”）中。很可能JavaScript引擎也是这种感觉。           

#####  执行与计划               
  我们的大脑可以看作类似于单线程运行的**事件循环**队列，就像JavaScript引擎那样。              
  * 在我们如何计划各种任务和我们的大脑如何实际执行这些计划之间，还存在着很大的差别。              
    * 我心里大致的计划是写啊写啊一直写，依次完成我脑海中已经按顺序排好的一系列要点。           
      我并没有将任何中断或非线性的行为纳入到我的写作计划中。         
      然而，尽管如此，实际上我的大脑还是在不停地切换状态。   
      * 这个较高层级的思考（计划）过程看起来并不怎么符合异步事件方式。             
      实际上，我们认真思考的时候很少是以事件的形式进行的。            
      取而代之的是，我们按照顺序（A，然后B，然后C）仔细计划着，并且会假定有某种形式的临时阻塞来保证B会等待A完成，C会等待B完成。            
    * 虽然在执行的层级上，我们的大脑是以异步事件方式运作的，           
    但我们的任务计划似乎还是以顺序、同步的方式进行：“我要先去商店，然后买点牛奶，然后去一下干洗店。”           
  * 如果说同步的大脑计划能够很好地映射到同步代码语句              
    开发者编写代码的时候是在计划一系列动作的发生。           
      优秀的开发者会认真计划。          
      “我需要把z设为x的值，然后把x设为y的值”，等等。          
    编写同步代码的时候，语句是一条接一条执行的，其工作方式非常类似于待办任务清单。 
      ```javascript          
      // 交换x和y（通过临时变量z）         
      z = x;          
      x = y;          
      y = z;    
      ```      
      这三条语句是同步执行的，          
        所以x = y会等待z = x执行完毕，        
        然后y = z等待x = y执行完毕。       
      换个说法就是，这三条语句临时绑定按照特定顺序一个接一个地执行。         
  * 那么我们的大脑在规划异步代码方面又是怎样的呢？             
    * 答案是代码（通过回调）表达异步的方式并不能很好地映射到同步的大脑计划行为。           
      如果我们这样计划一天中要做什么以及按什么顺序来做的话，事实就会像听上去那样荒谬。          
      但是，在实际执行方面，我们的大脑就是这么运作的。记住，不是多任务，而是快速的上下文切换。          
    * 对我们程序员来说，编写异步事件代码，特别是当回调是唯一的实现手段时，困难之处就在于这种思考/计划的意识流对我们中的绝大多数来说是不自然的。           
      我们的思考方式是一步一步的，但是从同步转换到异步之后，可用的工具（回调）却不是按照一步一步的方式来表达的。         
  * 唯一比不知道代码为什么崩溃更可怕的事情是，不知道为什么一开始它是工作的！            
      这就是经典的“纸牌屋”心理：“它可以工作，可我不知道为什么，所以谁也别碰它！”         
      你可能听说过“他人即地狱”（萨特）这种说法，对程序员来说则是“他人的代码即地狱”。         
      而我深信不疑的是：“不理解自己的代码才是地狱。”回调就是主要元凶之一。         
                
#####  嵌套回调与链式回调    
* 以这种方式线性地追踪这段代码还有几个问题  
   1. 这里我们得到了三个函数嵌套在一起构成的链，其中每个函数代表异步序列（任务，“进程”）中的一个步骤。             
   这种代码常常被称为回调地狱（callback hell），有时也被称为毁灭金字塔（pyramid of doom，得名于嵌套缩进产生的横向三角形状）。             
   但实际上回调地狱与嵌套和缩进几乎没有什么关系。它引起的问题要比这些严重得多。            
   本章后面的内容会就此类问题的现象和原因展开讨论。
    ```javascript           
    listen("click", function handler(evt) {             
    setTimeout(function request() {           
      ajax("http://some.url.1", function response(text) {         
        if(text == "hello") {       
          handler();      
        }       
        else if(text == "world") {        
          request();      
        }       
      });         
    }, 500);            
    });  
    ``` 
   
      * 一眼看去，这段代码似乎很自然地将其异步性映射到了顺序大脑计划。           
      一开始我们在等待click事件  
        首先（现在）我们有：          
        ```javascript
        listen("..", function handler(..) {         
          // ..       
        });      
        ``` 
        * 然后等待定时器启动  
        然后是将来，我们有：  
        ```javascript        
        setTimeout(function request(..) {         
          // ..       
        }, 500); 
        ```         
        * 然后等待Ajax响应返回  
        接着还是将来，我们有：
        ```javascript         
        ajax("..", function response(..) {          
          // ..       
        }); 
        ```        
        * 之后可能再重头开始  
        最后（最晚的将来），我们有： 
        ```javascript         
        if(..) {          
          // ..       
        }         
        else ..   
        ```      
      首先，例子中的步骤是按照1、2、3、4……的顺序，这只是一个偶然。         
      实际的异步JavaScript程序中总是有很多噪声，使得代码更加杂乱。       
      在大脑的演习中，我们需要熟练地绕过这些噪声，从一个函数跳到下一个函数。       
      对于这样满是回调的代码，理解其中的异步流不是不可能，但肯定不自然，也不容易，即使经过大量的练习也是如此。        
   2. 另外，其中还有一个隐藏更深的错误，但在代码例子中，这个错误并不明显。我们另外设计一个场景（伪代码）来展示这一点：   
      ```javascript
      doA(function() {        
        doB();      
        doC(function () {     
          doD();    
        })      
        doE();      
      });       
      doF();  
      ```      
      实际运行顺序是这样的： 
      ```javascript      
        doA()     
        doF()     
        doB()     
        doC()     
        doE()     
        doD()   
      ```  
      * 有些人可能会认为我的函数命名有意误导了大家，不过还是让我再试一次吧：
          ```javascript        
          doA(function() {        
            doC();      
            doD(function () {     
              doF();    
            })      
            doE();      
          });       
          doB();  
          ```      
      * 但即使你能够很轻松地得出结论，还是有一个可能导致严重问题的风险。你能够指出这一点吗？        
        如果doA(..)或doD(..)实际并不像我们假定的那样是异步的，情况会如何呢？     
        啊，那顺序就更麻烦了。     
        如果它们是同步的（或者根据程序当时的状态，只在某些情况下是同步的），那么现在运行顺序就是A→C→D→F→E→B。      
              
   3. 问题是出在嵌套上吗？是它导致跟踪异步流如此之难吗？确实，部分原因是这样。但是，让我们不用嵌套再把前面的嵌套事件/超时/Ajax的例子重写一遍吧：    
        ```javascript      
        listen("click:, handler);       
                
        function handler() {        
          setTimeout(request, 500);     
        }       
                
        function request() {        
          ajax("http://some.url.1", response);      
        }       
                
        function response(text) {       
          if(text == "hello") {     
            handler();    
          }     
          else if(text == "world") {      
            request();    
          }     
        }      
        ``` 
        * 这种组织形式的代码不像前面以嵌套/缩进的形式组织的代码那么容易识别了，但是它和回调地狱一样脆弱，易受影响。为什么？       
        在线性（顺序）地追踪这段代码的过程中，我们不得不从一个函数跳到下一个，再跳到下一个，在整个代码中跳来跳去以“查看”流程。        
        而且别忘了，这还是简化的形式，只考虑了最优情况。        
        我们都知道，真实的异步JavaScript程序代码要混乱得多，这使得这种追踪的难度会成倍增加。       
                
        * 还有一点需要注意：要把步骤2、步骤3和步骤4连接在一起让它们顺序执行，只用回调的话，代价可以接受的唯一方式是把步骤2硬编码到步骤1中，步骤3硬编码到步骤2中，步骤4硬编码到步骤3中，以此类推。        
        如果实际上步骤2总会引出步骤3是一个固定条件的话，硬编码本身倒不一定是坏事。      
        但是，硬编码肯定会使代码更脆弱一些，因为它并没有考虑可能导致步骤执行顺序偏离的异常情况。      
        比如，如果步骤2失败，就永远不会到达步骤3，不管是重试步骤2，还是跳转到其他错误处理流程，等等。      
  这些问题都可以通过在每个步骤中手工硬编码来解决，但这样的代码通常是重复的，并且在程序中的其他异步流中或其他步骤中无法复用。       
* 这才是回调地狱的真正问题所在！嵌套和缩进基本上只是转移注意力的枝节而已。
   * 尽管我们的大脑能够以顺序的方式（这个，然后这个，然后这个）计划一系列任务，但大脑运作的事件化的本质使得控制流的恢复/重试/复制几乎不费什么力气。      
      如果你出外办事的时候发现把购物清单落在了家里，那么这一天并不会因为你没有预知到这一点就成为世界末日了。你的大脑很容易就能针对这个小意外做出计划：回家拿清单，然后立刻返回商店就是了。    
   * 但是，手工硬编码（即使包含了硬编码的出错处理）回调的脆弱本性可就远没有这么优雅了。     
      一旦你指定（也就是预先计划）了所有的可能事件和路径，代码就会变得非常复杂，以至于无法维护和更新。    
   * 如果这还不够的话，我们还没有提及两个或更多回调continuation同时发生的情况，或者如果步骤3进入了带有gate或latch的并行回调的分支，还有……不行，我脑子转不动了，你怎么样？！       
   * 现在你抓住重点了吗？我们的顺序阻塞式的大脑计划行为无法很好地映射到面向回调的异步代码。
   这就是回调方式最主要的缺陷：对于它们在代码中表达异步的方式，我们的大脑需要努力才能同步得上。          


#### 2. 缺乏可信任性
信任问题  
也是更重要的一点，回调会受到**控制反转**的影响，                 
因为回调暗中把控制权交给第三方（通常是不受你控制的第三方工具！）来调用你代码中的continuation。               
这种控制转移导致一系列麻烦的信任问题，比如回调被调用的次数是否会超出预期。               
顺序的人脑计划和回调驱动的异步JavaScript代码之间的不匹配只是回调问题的一部分。                
还有一些更深入的问题需要考虑。               
##### 回调最大的问题是**控制反转**  
它会导致信任链的完全断裂。如果你的代码中使用了回调，尤其是但也不限于使用第三方工具，而且你还没有应用某种逻辑来解决所有这些**控制反转**导致的信任问题，那你的代码现在已经有了bug，即使它们还没有给你造成损害。隐藏的bug也是bug。确实是地狱。               
  * 让我们再次思考一下程序中把回调当作continuation（也就是后半部分）的概念： 
    ```javascript             
    // A            
    ajax("..", function(..) {           
      // C          
    });           
    // B   
    ```         
    * // A和// B发生于现在，在JavaScript主程序的直接控制之下。           
    * // C会延迟到将来发生，并且是在第三方的控制下——在本例中就是函数ajax(..)。从根本上来说，这种控制的转移通常不会给程序带来很多问题。           
    但是，请不要被这个小概率迷惑而认为这种控制切换不是什么大问题。实际上，这是回调驱动设计最严重（也是最微妙）的问题。           
      它以这样一个思路为中心：有时候ajax(..)（也就是你交付回调continuation的第三方）不是你编写的代码，也不在你的直接控制下。多数情况下，它是某个第三方提供的工具。          
      我们把这称为**控制反转**（inversion of control），也就是把自己程序一部分的执行控制交给某个第三方。在你的代码和第三方工具（一组你希望有人维护的东西）之间有一份并没有明确表达的契约。          

##### 你开始沿着这个兔子洞深挖下去，考虑着他们调用你的回调时所有可能的出错情况。
这里粗略列出了你能想到的分析工具可能出错的情况：       
###### 调用回调过早（在追踪之前）；  
还有一个信任问题是调用过早。            
在特定应用的术语中，这可能实际上是指在某个关键任务完成之前调用回调。          
但是更通用地来说，对于既可能在现在（同步）也可能在将来（异步）调用你的回调的工具来说，这个问题是明显的。          

  * 这种由同步或异步行为引起的不确定性几乎总会带来极大的bug追踪难度。            
  在某些圈子里，人们用虚构的十分疯狂的恶魔Zalgo来描述这种同步/异步噩梦。          
  常常会有“不要放出Zalgo”这样的呼喊，而这也引出了一条非常有效的建议：永远异步调用回调，即使就在**事件循环**的下一轮，这样，所有回调就都是可预测的异步调用了。         
  关于Zalgo的更多信息，可以参考Oren Golan的“Don't ReleaseZalgo! ”（`https://github.com/oren/oren.github.io/blob/master/posts/zalgo.md`）以及Issac Z. Schlueter的“Designing APIs for Asynchrony”（`http://blog.izs.me/post/59142742143/designing-apis-for-asynchrony`）。  
      
 ```javascript       
  function result(data) {         
    console.log(a);       
  }         
  var a = 0;          
  ajax("..pre-cached-url..", result);         
  a++;       
  ```   

  这段代码会打印出0（同步回调调用）还是1（异步回调调用）呢？这要视情况而定。          
  你可以看出Zalgo的不确定性给JavaScript程序带来的威胁。所以听上去有点傻的“不要放出Zalgo”实际上十分常用，并且也是有用的建议。永远要异步。          
  * 如果你不确定关注的API会不会永远异步执行怎么办呢？可以创建一个类似于这个“验证概念”版本的asyncify(..)工具：  
  ```javascript         
  function asyncify(fn) {         
    var origfn = fn,        
      intv = setTimeout(function() {      
        intv = null;    
        if(fn) fn();    
      }, 0)     
      fn = null;      
      return function() {     
        // 触发太快，在定时器intv触发指示异步转换发生之前？   
        if(intv) {    
          fn = origfn.bind.apply( 
            origfn,
            // 把封装器的this添加到bind(..)调用的参数中
            // 以及克里化（currying）所有传入参数
            [this].concat([].slice.call(arguments))
          );  
        }   
        // 已经是异步    
        else {    
          // 调用原来的函数  
          origfn.apply(this, arguments);  
        }   
      }     
  }     
  ```    
  可以像这样使用asyncify(..)：  
```javascript        
function result(data) {       
  console.log(a);     
}       
var a = 0;        
ajax("..pre-cached-url..", asyncify(result));       
a++;    
```    
  不管这个Ajax请求已经在缓存中并试图对回调立即调用，还是要从网络上取得，进而在将来异步完成，这段代码总是会输出1，而不是0——result(..)只能异步调用，这意味着a++有机会在result(..)之前运行。         
  好啊，又“解决”了一个信任问题！但这是低效的，而且也会带来膨胀的重复代码，使你的项目变得笨重。         
                
###### 调用回调过晚（或没有调用）；
那么完全不调用，这个信任问题又会怎样呢？如果这是个问题的话（可能应该是个问题！），你可能需要设置一个超时来取消事件。             
可以构造一个工具（这里展示的只是一个“验证概念”版本）来帮助实现这一点： 
```javascript           
function timeoutify(fn, delay) {            
  var intv = setTimeout(function() {          
    intv = null;        
    fn(new Error("Timeout!"));        
  }, delay);          
  return function() {         
    // 还没有超时？       
    if(intv) {        
      clearTimeout(intv);     
      fn.apply(this, arguments);      
    }       
  }         
}     
```         
以下是使用方式：           
```javascript 
// 使用“error-first风格“回调设计            
function foo(err, data) {           
  if(err) {         
    console.error(err);       
  }         
  else {          
    console.log(data);        
  }         
}           
ajax("http://some.url.1", timeoutify(foo, 500)); 
```           
                 
###### 调用回调的次数太少或太多（就像你遇到过的问题！）；  
第三方工具——五个回调的故事              
可能现在还不能很明显地看出为什么这是一个大问题。让我构造一个有点夸张的场景来说明这种信任风险吧。            
在最后一页，当用户点击“确定”就可以购买电视时，你需要调用（假设由某个分析追踪公司提供的）第三方函数以便跟踪这个交易。你注意到，可能是为了提高性能，他们提供了一个看似用于异步追踪的工具，这意味着你需要传入一个回调函数。在传入的这个continuation中，你需要提供向客户收费和展示感谢页面的最终代码。 

```javascript         
analytics.trackPurchase( purchaseData, function() {       
  chargeCreditCard();     
  displayThankyouPage();      
});   
```    
你们的一位高级客户购买了一台电视，信用卡却被刷了五次          
分析公司的开发者开发了一些实验性的代码，在某种情况下，会在五秒钟内每秒重试一次传入的回调函数，然后才会因超时而失败。他们从来没打算把这段代码提交到产品中，但不知道为什么却这样做了         
你需要找到某种方法来保护结账代码，保证不再出问题。经过修补之后，你实现了像下面这样的简单临时代码，大家似乎也很满意：        
```javascript  
var tracked = false;        
analytics.trackPurchase(purchaseData, function() {        
  if(!tracked) {      
    tracked = true;   
    chargeCreditCard();   
    displayThankyouPage();    
  }     
}); 
```      
这里我们其实就是创建了一个latch来处理对回调的多个并发调用。   
   
###### 没有把所需的环境/参数成功传给你的回调函数；  
不只是别人的代码              
请思考这一点：你能够真正信任理论上（在自己的代码库中）你可以控制的工具吗？           
不妨这样考虑：多数人都同意，至少在某种程度上我们应该在内部函数中构建一些防御性的输入参数检查，以便减少或阻止无法预料的问题。            
过分信任输入：   
  ```javascript        
  function addNumbers(x, y) {         
    // +是可以重载的，通过类型转换，也可以是字符串连接       
    // 所以根据传入参数的不同，这个去处并不是严格安全的       
    return x + y;       
  }         
  addNumbers(21, 21); // 42         
  addNumbers(21, "21"); // "2121" 
  ```        
针对不信任输入的防御性代码：   
  ```javascript         
  function addNumbers(x, y) {         
    // 确保输入为数字        
    if(typeof x != "number" || typeof y != "number") {        
      throw Error("Bad parameters");      
    }       
    // 如果到达这里，可以通过+安全的进行数字相加        
    return x + y;       
  }         
  addNumbers(21, "21"); // "2121"         
  addNumbers(21, "21"); // Error: "Bad parameters"   
  ```       
            
依旧安全但更友好一些的：   
  ```javascript         
  function addNumbers(x, y) [         
    // 确保输入为数字        
    x = Number(x);        
    y = Number(y);        
    // +安全进行数字相加        
    return x + y;       
  }         
  addNumbers(21, 21); // 42         
  addNumbers(21, "21"); // 42  
  ```       
不管你怎么做，这种类型的检查/规范化的过程对于函数输入是很常见的，即使是对于理论上完全可以信任的代码。大体上说，这等价于那条地缘政治原则：“信任，但要核实。”           
所以，据此是不是可以推断出，对于异步函数回调的组成，我们应该要做同样的事情，而不只是针对外部代码，甚至是我们知道在我们自己控制下的代码？当然应该。           
但是，回调并没有为我们提供任何东西来支持这一点。我们不得不自己构建全部的机制，而且通常为每个异步回调重复这样的工作最后都成了负担。           
            
###### 吞掉可能出现的错误或异常；   
尝试挽救回调
可以发明一些特定逻辑来解决这些信任问题，但是其难度高于应有的水平，可能会产生更笨重、更难维护的代码，并且缺少足够的保护，其中的损害要直到你受到bug的影响才会被发现。               
回调设计存在几个变体，意在解决前面讨论的一些信任问题（不是全部！）。这种试图从回调模式内部挽救它的意图是勇敢的，但却注定要失败。              
####### 1. 为了更优雅地处理错误，有些API设计提供了分离回调（一个用于成功通知，一个用于出错通知）：  
```javascript            
function success(data) {            
  console.log(data);          
}           
function failure(err) {           
  console.log(err);         
}           
ajax("http://some.url.1", success, failure);  
```          
在这种设计下，API的出错处理函数failure()常常是可选的，如果没有提供的话，就是假定这个错误可以吞掉。           
ES6 Promise API使用的就是这种分离回调设计。第3章会介绍ES6Promise的更多细节。           

####### 2. 还有一种常见的回调模式叫作“error-first风格”              
（有时候也称为“Node风格”，因为几乎所有Node.js API都采用这种风格），            
其中回调的第一个参数保留用作错误对象（如果有的话）。            
如果成功的话，这个参数就会被清空/置假（后续的参数就是成功数据）。           
不过，如果产生了错误结果，那么第一个参数就会被置起/置真（通常就不会再传递其他结果）：
  ```javascript           
  function response(err, data) {          
    // 出错？        
    if(err) {       
      console.error(err);     
    }       
    // 否则认为成功       
    else {        
      console.log(data);      
    }       
  }         
  ajax("http://some.url.1", response); 
  ```         
* 在这两种情况下，都应该注意到以下几点。             
   * 首先，这并没有像表面看上去那样真正解决主要的信任问题。           
   这并没有涉及阻止或过滤不想要的重复调用回调的问题。         
   现在事情更糟了，因为现在你可能同时得到成功或者失败的结果，或者都没有，并且你还是不得不编码处理所有这些情况。          
   * 另外，不要忽略这个事实：尽管这是一种你可以采用的标准模式，但是它肯定更加冗长和模式化，可复用性不高，所以你还得不厌其烦地给应用中的每个回调添加这样的代码。           
         
###### ……           
* 这感觉就像是一个麻烦列表，实际上它就是。你可能已经开始慢慢意识到，对于被传给你无法信任的工具的每个回调，你都将不得不创建大量的混乱逻辑。现在你应该更加明白回调地狱是多像地狱了吧。       
  
                  
     

      
* 我们需要一个通用的方案来解决这些信任问题。不管我们创建多少回调，这一方案都应可以复用，且没有重复代码的开销。                
                
### 我们需要比回调更好的机制。                   
  可能现在你希望有内建的API或其他语言机制来解决这些问题。最终，ES6带着一些极好的答案登场了                 
  很多开发者因为更好的异步模式promise而激动不已。                 
  到目前为止，回调提供了很好的服务，但是未来的JavaScript需要更高级、功能更强大的异步模式。本书接下来的几章会深入探讨这些新型技术。                 
                    
                    


# ajax
axios


# 如何实现上传图片 FormData
> [《HTML5权威指南》](https://weread.qq.com/web/reader/98232c3071a122f5982dffckc81322c012c81e728d9d180)
